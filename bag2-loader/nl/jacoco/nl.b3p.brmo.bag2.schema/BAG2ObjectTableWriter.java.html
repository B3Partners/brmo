<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="nl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BAG2ObjectTableWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BRMO BAG 2.0 loader</a> &gt; <a href="index.source.html" class="el_package">nl.b3p.brmo.bag2.schema</a> &gt; <span class="el_source">BAG2ObjectTableWriter.java</span></div><h1>BAG2ObjectTableWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2021 B3Partners B.V.
 *
 * SPDX-License-Identifier: MIT
 *
 */

package nl.b3p.brmo.bag2.schema;

import static nl.b3p.brmo.bag2.schema.BAG2Schema.TIJDSTIP_NIETBAGLV;

import nl.b3p.brmo.bag2.loader.BAG2GMLMutatieGroepStream;
import nl.b3p.brmo.bag2.loader.BAG2Mutatie;
import nl.b3p.brmo.bag2.loader.BAG2MutatieGroep;
import nl.b3p.brmo.bag2.loader.BAG2ToevoegingMutatie;
import nl.b3p.brmo.bag2.loader.BAG2WijzigingMutatie;
import nl.b3p.brmo.schema.ObjectTableWriter;
import nl.b3p.brmo.schema.ObjectType;
import nl.b3p.brmo.schema.SchemaObjectInstance;
import nl.b3p.brmo.schema.SchemaSQLMapper;
import nl.b3p.brmo.schema.mapping.AttributeColumnMapping;
import nl.b3p.brmo.sql.PreparedStatementQueryBatch;
import nl.b3p.brmo.sql.QueryBatch;
import nl.b3p.brmo.sql.dialect.SQLDialect;

import org.apache.commons.io.input.CountingInputStream;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.io.InputStream;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class BAG2ObjectTableWriter extends ObjectTableWriter {
<span class="nc" id="L41">    private static final Log log = LogFactory.getLog(BAG2ObjectTableWriter.class);</span>

    private boolean ignoreDuplicates;

    /** Set of seen keys per object type to enable skipping of duplicates */
<span class="nc" id="L46">    private Map&lt;BAG2ObjectType, Set&lt;Pair&lt;Object, Object&gt;&gt;&gt; keysPerObjectType = null;</span>

<span class="nc" id="L48">    public class BAG2Progress extends Progress {</span>
<span class="nc" id="L49">        private Map&lt;ObjectType, QueryBatch&gt; deleteBatches = new HashMap&lt;&gt;();</span>

<span class="nc" id="L51">        private long updatedCount = 0;</span>

        private BAG2GMLMutatieGroepStream.BagInfo bagInfo;

<span class="nc" id="L55">        private BAG2ObjectType currentObjectType = null;</span>

        public long getUpdatedCount() {
<span class="nc" id="L58">            return updatedCount;</span>
        }

        public BAG2ObjectTableWriter getWriter() {
<span class="nc" id="L62">            return BAG2ObjectTableWriter.this;</span>
        }

        public BAG2GMLMutatieGroepStream.BagInfo getMutatieInfo() {
<span class="nc" id="L66">            return bagInfo;</span>
        }

        public BAG2ObjectType getCurrentObjectType() {
<span class="nc" id="L70">            return currentObjectType;</span>
        }
    }

    public BAG2ObjectTableWriter(
            Connection connection, SQLDialect dialect, SchemaSQLMapper schemaSQLMapper) {
<span class="nc" id="L76">        super(connection, dialect, schemaSQLMapper);</span>
<span class="nc" id="L77">        this.setProgress(this.new BAG2Progress());</span>
<span class="nc" id="L78">    }</span>

    public void setIgnoreDuplicates(boolean ignoreDuplicates) {
<span class="nc" id="L81">        this.ignoreDuplicates = ignoreDuplicates;</span>
<span class="nc" id="L82">    }</span>

    public boolean getIgnoreDuplicates() {
<span class="nc" id="L85">        return ignoreDuplicates;</span>
    }

    public BAG2Progress getProgress() {
<span class="nc" id="L89">        return (BAG2Progress) super.getProgress();</span>
    }

    public Map&lt;BAG2ObjectType, Set&lt;Pair&lt;Object, Object&gt;&gt;&gt; getKeysPerObjectType() {
<span class="nc" id="L93">        return keysPerObjectType;</span>
    }

    public void setKeysPerObjectType(
            Map&lt;BAG2ObjectType, Set&lt;Pair&lt;Object, Object&gt;&gt;&gt; keysPerObjectType) {
<span class="nc" id="L98">        this.keysPerObjectType = keysPerObjectType;</span>
<span class="nc" id="L99">    }</span>

    public void start() throws SQLException {
<span class="nc" id="L102">        BAG2Progress progress = this.new BAG2Progress();</span>
<span class="nc" id="L103">        progress.setInitialLoad(true);</span>
<span class="nc" id="L104">        super.start(progress);</span>
<span class="nc" id="L105">        updateProgress(Stage.PARSE_INPUT);</span>
<span class="nc" id="L106">    }</span>

    private void deletePreviousVersion(BAG2Object object) throws Exception {
<span class="nc" id="L109">        BAG2ObjectType objectType = object.getObjectType();</span>
<span class="nc" id="L110">        Map&lt;ObjectType, QueryBatch&gt; deleteBatches = getProgress().deleteBatches;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (!deleteBatches.containsKey(objectType)) {</span>
<span class="nc" id="L112">            String args =</span>
<span class="nc" id="L113">                    objectType.getPrimaryKeys().stream()</span>
<span class="nc" id="L114">                            .map(</span>
                                    k -&gt;
<span class="nc" id="L116">                                            getSchemaSQLMapper()</span>
<span class="nc" id="L117">                                                            .getColumnNameForObjectType(</span>
<span class="nc" id="L118">                                                                    objectType, k.getName())</span>
                                                    + &quot; = ?&quot;)
<span class="nc" id="L120">                            .collect(Collectors.joining(&quot; and &quot;));</span>
            // Array attributes are deleted because of 'on delete cascade' on the foreign key
<span class="nc" id="L122">            String sql =</span>
<span class="nc" id="L123">                    String.format(</span>
                            &quot;delete from %s where %s&quot;,
<span class="nc" id="L125">                            getSchemaSQLMapper()</span>
<span class="nc" id="L126">                                    .getTableNameForObjectType(objectType, getTablePrefix()),</span>
                            args);
            // Set batch size to 1 so deletes are executed immediately, for performance deletes
            // could be batched but
            // they would need to be executed before inserts of updated versions (with the same
            // key), that is more
            // complicated
<span class="nc" id="L133">            deleteBatches.put(objectType, new PreparedStatementQueryBatch(getConnection(), sql, 1));</span>
        }
<span class="nc" id="L135">        QueryBatch batch = deleteBatches.get(objectType);</span>

<span class="nc" id="L137">        Object[] params =</span>
<span class="nc" id="L138">                objectType.getPrimaryKeys().stream()</span>
<span class="nc" id="L139">                        .map(</span>
                                pk -&gt; {
                                    try {
<span class="nc" id="L142">                                        AttributeColumnMapping mapping =</span>
<span class="nc" id="L143">                                                objectType.getAttributeByName(pk.getName());</span>
<span class="nc" id="L144">                                        Object attribute = object.getAttributes().get(pk.getName());</span>
<span class="nc" id="L145">                                        return mapping.toQueryParameter(attribute);</span>
<span class="nc" id="L146">                                    } catch (Exception e) {</span>
<span class="nc" id="L147">                                        throw new RuntimeException(e);</span>
                                    }
                                })
<span class="nc" id="L150">                        .toArray();</span>

<span class="nc" id="L152">        boolean executed = batch.addBatch(params);</span>
<span class="nc" id="L153">        getProgress().updatedCount++;</span>

<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (executed) {</span>
<span class="nc" id="L156">            updateProgress();</span>
        }
<span class="nc" id="L158">    }</span>

    @Override
    protected void addObjectToBatch(SchemaObjectInstance object) throws Exception {
        // Never write NIET BAG objects to database
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (!object.getAttributes().containsKey(TIJDSTIP_NIETBAGLV)) {</span>
<span class="nc" id="L164">            super.addObjectToBatch(object);</span>
        }
<span class="nc" id="L166">    }</span>

    public void write(InputStream bagXml) throws Exception {
<span class="nc" id="L169">        CountingInputStream counter = new CountingInputStream(bagXml);</span>
<span class="nc" id="L170">        BAG2GMLMutatieGroepStream bag2Objects = new BAG2GMLMutatieGroepStream(counter);</span>
<span class="nc" id="L171">        getProgress().bagInfo = bag2Objects.getBagInfo();</span>
<span class="nc" id="L172">        updateProgress(Stage.LOAD_OBJECTS);</span>

        try {
<span class="nc bnc" id="L175" title="All 2 branches missed.">            for (BAG2MutatieGroep mutatieGroep : bag2Objects) {</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">                for (BAG2Mutatie mutatie : mutatieGroep.getMutaties()) {</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                    if (mutatie instanceof BAG2WijzigingMutatie) {</span>
                        // Don't do an update but a simpler delete and insert of the updated version
                        // Executed on main thread, but worker thread will not be executing new
                        // versions of the record we're
                        // deleting

                        // No check for duplicates for wijzigingen: no harm in doing the same
                        // wijziging twice and we
                        // can't tell by only the keys if it is exactly the same wijziging but in
                        // the maandmutaties for
                        // a different gemeente or the same version changed twice

<span class="nc" id="L189">                        BAG2WijzigingMutatie wijzigingMutatie = (BAG2WijzigingMutatie) mutatie;</span>
<span class="nc" id="L190">                        deletePreviousVersion(wijzigingMutatie.getWas());</span>
<span class="nc" id="L191">                        addObjectToBatch(wijzigingMutatie.getWordt());</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                    } else if (mutatie instanceof BAG2ToevoegingMutatie) {</span>
<span class="nc" id="L193">                        BAG2ToevoegingMutatie toevoegingMutatie = (BAG2ToevoegingMutatie) mutatie;</span>

<span class="nc bnc" id="L195" title="All 4 branches missed.">                        if (ignoreDuplicates &amp;&amp; isDuplicate(toevoegingMutatie.getToevoeging())) {</span>
<span class="nc" id="L196">                            continue;</span>
                        }

<span class="nc" id="L199">                        prepareDatabaseForObject(toevoegingMutatie.getToevoeging());</span>
<span class="nc" id="L200">                        getProgress().incrementObjectCount();</span>
<span class="nc" id="L201">                        addObjectToBatch(toevoegingMutatie.getToevoeging());</span>
                    }

<span class="nc bnc" id="L204" title="All 2 branches missed.">                    if (getObjectLimit() != null</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                            &amp;&amp; getProgress().getObjectCount() == getObjectLimit()) {</span>
<span class="nc" id="L206">                        break;</span>
                    }
<span class="nc" id="L208">                }</span>
<span class="nc" id="L209">            }</span>
<span class="nc" id="L210">        } catch (Exception e) {</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">            if (isMultithreading()) {</span>
                // Make sure worker thread exits
<span class="nc" id="L213">                abortWorkerThread();</span>
            }
<span class="nc" id="L215">            throw e;</span>
<span class="nc" id="L216">        }</span>
<span class="nc" id="L217">    }</span>

    private boolean isDuplicate(BAG2Object object) {
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (keysPerObjectType == null) {</span>
<span class="nc" id="L221">            throw new IllegalStateException(</span>
                    &quot;keysPerObject type must be set to enable ignoring of duplicates&quot;);
        }
        // Primary keys for all BAG2 objects are always same
<span class="nc" id="L225">        Pair&lt;Object, Object&gt; keys =</span>
<span class="nc" id="L226">                Pair.of(</span>
<span class="nc" id="L227">                        object.getAttributes().get(&quot;identificatie&quot;),</span>
<span class="nc" id="L228">                        object.getAttributes().get(&quot;voorkomenidentificatie&quot;));</span>
<span class="nc" id="L229">        Set&lt;Pair&lt;Object, Object&gt;&gt; seenKeys =</span>
<span class="nc" id="L230">                keysPerObjectType.computeIfAbsent(object.getObjectType(), k -&gt; new HashSet&lt;&gt;());</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (seenKeys.contains(keys)) {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L233">                log.debug(</span>
<span class="nc" id="L234">                        String.format(</span>
                                &quot;\rIgnoring duplicate %s %s&quot;,
<span class="nc" id="L236">                                object.getObjectType().getName(), keys));</span>
            }
<span class="nc" id="L238">            return true;</span>
        }
<span class="nc" id="L240">        seenKeys.add(keys);</span>
<span class="nc" id="L241">        return false;</span>
    }

    public void complete() throws Exception {
<span class="nc" id="L245">        super.endOfObjects();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">        for (QueryBatch batch : getProgress().deleteBatches.values()) {</span>
<span class="nc" id="L247">            batch.executeBatch();</span>
<span class="nc" id="L248">        }</span>
<span class="nc" id="L249">        super.complete();</span>
<span class="nc" id="L250">        super.closeBatches();</span>
<span class="nc" id="L251">    }</span>

    @Override
    public void createKeys(ObjectType objectType) throws Exception {
<span class="nc" id="L255">        this.getProgress().currentObjectType = (BAG2ObjectType) objectType;</span>
<span class="nc" id="L256">        super.createKeys(objectType);</span>
<span class="nc" id="L257">    }</span>

    @Override
    public void createIndexes(ObjectType objectType) throws Exception {
<span class="nc" id="L261">        this.getProgress().currentObjectType = (BAG2ObjectType) objectType;</span>
<span class="nc" id="L262">        super.createIndexes(objectType);</span>
<span class="nc" id="L263">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>