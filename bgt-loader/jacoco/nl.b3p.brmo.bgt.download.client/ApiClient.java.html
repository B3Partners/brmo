<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="nl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ApiClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BRMO BGT / IMGeo CityGML loader</a> &gt; <a href="index.source.html" class="el_package">nl.b3p.brmo.bgt.download.client</a> &gt; <span class="el_source">ApiClient.java</span></div><h1>ApiClient.java</h1><pre class="source lang-java linenums">/*
 * BGT Download API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package nl.b3p.brmo.bgt.download.client;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import java.io.InputStream;
import java.net.URI;
import java.net.URLEncoder;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.StringJoiner;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * Configuration and utility class for API clients.
 *
 * &lt;p&gt;This class can be constructed and modified, then used to instantiate the
 * various API classes. The API classes use the settings in this class to
 * configure themselves, but otherwise do not store a link to this class.&lt;/p&gt;
 *
 * &lt;p&gt;This class is mutable and not synchronized, so it is not thread-safe.
 * The API classes generated from this are immutable and thread-safe.&lt;/p&gt;
 *
 * &lt;p&gt;The setter methods of this class return the current object to facilitate
 * a fluent style of configuration.&lt;/p&gt;
 */
@javax.annotation.processing.Generated(value = &quot;org.openapitools.codegen.languages.JavaClientCodegen&quot;)
public class ApiClient {

  private HttpClient.Builder builder;
  private ObjectMapper mapper;
  private String scheme;
  private String host;
  private int port;
  private String basePath;
  private Consumer&lt;HttpRequest.Builder&gt; interceptor;
  private Consumer&lt;HttpResponse&lt;InputStream&gt;&gt; responseInterceptor;
  private Consumer&lt;HttpResponse&lt;String&gt;&gt; asyncResponseInterceptor;
  private Duration readTimeout;

  private static String valueToString(Object value) {
<span class="nc bnc" id="L67" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L68">      return &quot;&quot;;</span>
    }
<span class="nc bnc" id="L70" title="All 2 branches missed.">    if (value instanceof OffsetDateTime) {</span>
<span class="nc" id="L71">      return ((OffsetDateTime) value).format(DateTimeFormatter.ISO_OFFSET_DATE_TIME);</span>
    }
<span class="nc" id="L73">    return value.toString();</span>
  }

  /**
   * URL encode a string in the UTF-8 encoding.
   *
   * @param s String to encode.
   * @return URL-encoded representation of the input string.
   */
  public static String urlEncode(String s) {
<span class="nc" id="L83">    return URLEncoder.encode(s, UTF_8).replaceAll(&quot;\\+&quot;, &quot;%20&quot;);</span>
  }

  /**
   * Convert a URL query name/value parameter to a list of encoded {@link Pair}
   * objects.
   *
   * &lt;p&gt;The value can be null, in which case an empty list is returned.&lt;/p&gt;
   *
   * @param name The query name parameter.
   * @param value The query value, which may not be a collection but may be
   *              null.
   * @return A singleton list of the {@link Pair} objects representing the input
   * parameters, which is encoded for use in a URL. If the value is null, an
   * empty list is returned.
   */
  public static List&lt;Pair&gt; parameterToPairs(String name, Object value) {
<span class="nc bnc" id="L100" title="All 6 branches missed.">    if (name == null || name.isEmpty() || value == null) {</span>
<span class="nc" id="L101">      return Collections.emptyList();</span>
    }
<span class="nc" id="L103">    return Collections.singletonList(new Pair(urlEncode(name), urlEncode(valueToString(value))));</span>
  }

  /**
   * Convert a URL query name/collection parameter to a list of encoded
   * {@link Pair} objects.
   *
   * @param collectionFormat The swagger collectionFormat string (csv, tsv, etc).
   * @param name The query name parameter.
   * @param values A collection of values for the given query name, which may be
   *               null.
   * @return A list of {@link Pair} objects representing the input parameters,
   * which is encoded for use in a URL. If the values collection is null, an
   * empty list is returned.
   */
  public static List&lt;Pair&gt; parameterToPairs(
      String collectionFormat, String name, Collection&lt;?&gt; values) {
<span class="nc bnc" id="L120" title="All 8 branches missed.">    if (name == null || name.isEmpty() || values == null || values.isEmpty()) {</span>
<span class="nc" id="L121">      return Collections.emptyList();</span>
    }

    // get the collection format (default: csv)
<span class="nc bnc" id="L125" title="All 4 branches missed.">    String format = collectionFormat == null || collectionFormat.isEmpty() ? &quot;csv&quot; : collectionFormat;</span>

    // create the params based on the collection format
<span class="nc bnc" id="L128" title="All 2 branches missed.">    if (&quot;multi&quot;.equals(format)) {</span>
<span class="nc" id="L129">      return values.stream()</span>
<span class="nc" id="L130">          .map(value -&gt; new Pair(urlEncode(name), urlEncode(valueToString(value))))</span>
<span class="nc" id="L131">          .collect(Collectors.toList());</span>
    }

    String delimiter;
<span class="nc bnc" id="L135" title="All 5 branches missed.">    switch(format) {</span>
      case &quot;csv&quot;:
<span class="nc" id="L137">        delimiter = urlEncode(&quot;,&quot;);</span>
<span class="nc" id="L138">        break;</span>
      case &quot;ssv&quot;:
<span class="nc" id="L140">        delimiter = urlEncode(&quot; &quot;);</span>
<span class="nc" id="L141">        break;</span>
      case &quot;tsv&quot;:
<span class="nc" id="L143">        delimiter = urlEncode(&quot;\t&quot;);</span>
<span class="nc" id="L144">        break;</span>
      case &quot;pipes&quot;:
<span class="nc" id="L146">        delimiter = urlEncode(&quot;|&quot;);</span>
<span class="nc" id="L147">        break;</span>
      default:
<span class="nc" id="L149">        throw new IllegalArgumentException(&quot;Illegal collection format: &quot; + collectionFormat);</span>
    }

<span class="nc" id="L152">    StringJoiner joiner = new StringJoiner(delimiter);</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">    for (Object value : values) {</span>
<span class="nc" id="L154">      joiner.add(urlEncode(valueToString(value)));</span>
<span class="nc" id="L155">    }</span>

<span class="nc" id="L157">    return Collections.singletonList(new Pair(urlEncode(name), joiner.toString()));</span>
  }

  /**
   * Ctor.
   */
<span class="nc" id="L163">  public ApiClient() {</span>
<span class="nc" id="L164">    this.builder = createDefaultHttpClientBuilder();</span>
<span class="nc" id="L165">    this.mapper = createDefaultObjectMapper();</span>
<span class="nc" id="L166">    updateBaseUri(getDefaultBaseUri());</span>
<span class="nc" id="L167">    interceptor = null;</span>
<span class="nc" id="L168">    readTimeout = null;</span>
<span class="nc" id="L169">    responseInterceptor = null;</span>
<span class="nc" id="L170">    asyncResponseInterceptor = null;</span>
<span class="nc" id="L171">  }</span>

  /**
   * Ctor.
   */
<span class="nc" id="L176">  public ApiClient(HttpClient.Builder builder, ObjectMapper mapper, String baseUri) {</span>
<span class="nc" id="L177">    this.builder = builder;</span>
<span class="nc" id="L178">    this.mapper = mapper;</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">    updateBaseUri(baseUri != null ? baseUri : getDefaultBaseUri());</span>
<span class="nc" id="L180">    interceptor = null;</span>
<span class="nc" id="L181">    readTimeout = null;</span>
<span class="nc" id="L182">    responseInterceptor = null;</span>
<span class="nc" id="L183">    asyncResponseInterceptor = null;</span>
<span class="nc" id="L184">  }</span>

  protected ObjectMapper createDefaultObjectMapper() {
<span class="nc" id="L187">    ObjectMapper mapper = new ObjectMapper();</span>
<span class="nc" id="L188">    mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span>
<span class="nc" id="L189">    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);</span>
<span class="nc" id="L190">    mapper.configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false);</span>
<span class="nc" id="L191">    mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span>
<span class="nc" id="L192">    mapper.enable(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);</span>
<span class="nc" id="L193">    mapper.enable(DeserializationFeature.READ_ENUMS_USING_TO_STRING);</span>
<span class="nc" id="L194">    mapper.disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);</span>
<span class="nc" id="L195">    mapper.registerModule(new JavaTimeModule());</span>
<span class="nc" id="L196">    return mapper;</span>
  }

  protected String getDefaultBaseUri() {
<span class="nc" id="L200">    return &quot;https://api.pdok.nl/lv/bgt/download/v1_0&quot;;</span>
  }

  protected HttpClient.Builder createDefaultHttpClientBuilder() {
<span class="nc" id="L204">    return HttpClient.newBuilder();</span>
  }

  public void updateBaseUri(String baseUri) {
<span class="nc" id="L208">    URI uri = URI.create(baseUri);</span>
<span class="nc" id="L209">    scheme = uri.getScheme();</span>
<span class="nc" id="L210">    host = uri.getHost();</span>
<span class="nc" id="L211">    port = uri.getPort();</span>
<span class="nc" id="L212">    basePath = uri.getRawPath();</span>
<span class="nc" id="L213">  }</span>

  /**
   * Set a custom {@link HttpClient.Builder} object to use when creating the
   * {@link HttpClient} that is used by the API client.
   *
   * @param builder Custom client builder.
   * @return This object.
   */
  public ApiClient setHttpClientBuilder(HttpClient.Builder builder) {
<span class="nc" id="L223">    this.builder = builder;</span>
<span class="nc" id="L224">    return this;</span>
  }

  /**
   * Get an {@link HttpClient} based on the current {@link HttpClient.Builder}.
   *
   * &lt;p&gt;The returned object is immutable and thread-safe.&lt;/p&gt;
   *
   * @return The HTTP client.
   */
  public HttpClient getHttpClient() {
<span class="nc" id="L235">    return builder.build();</span>
  }

  /**
   * Set a custom {@link ObjectMapper} to serialize and deserialize the request
   * and response bodies.
   *
   * @param mapper Custom object mapper.
   * @return This object.
   */
  public ApiClient setObjectMapper(ObjectMapper mapper) {
<span class="nc" id="L246">    this.mapper = mapper;</span>
<span class="nc" id="L247">    return this;</span>
  }

  /**
   * Get a copy of the current {@link ObjectMapper}.
   *
   * @return A copy of the current object mapper.
   */
  public ObjectMapper getObjectMapper() {
<span class="nc" id="L256">    return mapper.copy();</span>
  }

  /**
   * Set a custom host name for the target service.
   *
   * @param host The host name of the target service.
   * @return This object.
   */
  public ApiClient setHost(String host) {
<span class="nc" id="L266">    this.host = host;</span>
<span class="nc" id="L267">    return this;</span>
  }

  /**
   * Set a custom port number for the target service.
   *
   * @param port The port of the target service. Set this to -1 to reset the
   *             value to the default for the scheme.
   * @return This object.
   */
  public ApiClient setPort(int port) {
<span class="nc" id="L278">    this.port = port;</span>
<span class="nc" id="L279">    return this;</span>
  }

  /**
   * Set a custom base path for the target service, for example '/v2'.
   *
   * @param basePath The base path against which the rest of the path is
   *                 resolved.
   * @return This object.
   */
  public ApiClient setBasePath(String basePath) {
<span class="nc" id="L290">    this.basePath = basePath;</span>
<span class="nc" id="L291">    return this;</span>
  }

  /**
   * Get the base URI to resolve the endpoint paths against.
   *
   * @return The complete base URI that the rest of the API parameters are
   * resolved against.
   */
  public String getBaseUri() {
<span class="nc bnc" id="L301" title="All 2 branches missed.">    return scheme + &quot;://&quot; + host + (port == -1 ? &quot;&quot; : &quot;:&quot; + port) + basePath;</span>
  }

  /**
   * Set a custom scheme for the target service, for example 'https'.
   *
   * @param scheme The scheme of the target service
   * @return This object.
   */
  public ApiClient setScheme(String scheme){
<span class="nc" id="L311">    this.scheme = scheme;</span>
<span class="nc" id="L312">    return this;</span>
  }

  /**
   * Set a custom request interceptor.
   *
   * &lt;p&gt;A request interceptor is a mechanism for altering each request before it
   * is sent. After the request has been fully configured but not yet built, the
   * request builder is passed into this function for further modification,
   * after which it is sent out.&lt;/p&gt;
   *
   * &lt;p&gt;This is useful for altering the requests in a custom manner, such as
   * adding headers. It could also be used for logging and monitoring.&lt;/p&gt;
   *
   * @param interceptor A function invoked before creating each request. A value
   *                    of null resets the interceptor to a no-op.
   * @return This object.
   */
  public ApiClient setRequestInterceptor(Consumer&lt;HttpRequest.Builder&gt; interceptor) {
<span class="nc" id="L331">    this.interceptor = interceptor;</span>
<span class="nc" id="L332">    return this;</span>
  }

  /**
   * Get the custom interceptor.
   *
   * @return The custom interceptor that was set, or null if there isn't any.
   */
  public Consumer&lt;HttpRequest.Builder&gt; getRequestInterceptor() {
<span class="nc" id="L341">    return interceptor;</span>
  }

  /**
   * Set a custom response interceptor.
   *
   * &lt;p&gt;This is useful for logging, monitoring or extraction of header variables&lt;/p&gt;
   *
   * @param interceptor A function invoked before creating each request. A value
   *                    of null resets the interceptor to a no-op.
   * @return This object.
   */
  public ApiClient setResponseInterceptor(Consumer&lt;HttpResponse&lt;InputStream&gt;&gt; interceptor) {
<span class="nc" id="L354">    this.responseInterceptor = interceptor;</span>
<span class="nc" id="L355">    return this;</span>
  }

 /**
   * Get the custom response interceptor.
   *
   * @return The custom interceptor that was set, or null if there isn't any.
   */
  public Consumer&lt;HttpResponse&lt;InputStream&gt;&gt; getResponseInterceptor() {
<span class="nc" id="L364">    return responseInterceptor;</span>
  }

  /**
   * Set a custom async response interceptor. Use this interceptor when asyncNative is set to 'true'.
   *
   * &lt;p&gt;This is useful for logging, monitoring or extraction of header variables&lt;/p&gt;
   *
   * @param interceptor A function invoked before creating each request. A value
   *                    of null resets the interceptor to a no-op.
   * @return This object.
   */
  public ApiClient setAsyncResponseInterceptor(Consumer&lt;HttpResponse&lt;String&gt;&gt; interceptor) {
<span class="nc" id="L377">    this.asyncResponseInterceptor = interceptor;</span>
<span class="nc" id="L378">    return this;</span>
  }

 /**
   * Get the custom async response interceptor. Use this interceptor when asyncNative is set to 'true'.
   *
   * @return The custom interceptor that was set, or null if there isn't any.
   */
  public Consumer&lt;HttpResponse&lt;String&gt;&gt; getAsyncResponseInterceptor() {
<span class="nc" id="L387">    return asyncResponseInterceptor;</span>
  }

  /**
   * Set the read timeout for the http client.
   *
   * &lt;p&gt;This is the value used by default for each request, though it can be
   * overridden on a per-request basis with a request interceptor.&lt;/p&gt;
   *
   * @param readTimeout The read timeout used by default by the http client.
   *                    Setting this value to null resets the timeout to an
   *                    effectively infinite value.
   * @return This object.
   */
  public ApiClient setReadTimeout(Duration readTimeout) {
<span class="nc" id="L402">    this.readTimeout = readTimeout;</span>
<span class="nc" id="L403">    return this;</span>
  }

  /**
   * Get the read timeout that was set.
   *
   * @return The read timeout, or null if no timeout was set. Null represents
   * an infinite wait time.
   */
  public Duration getReadTimeout() {
<span class="nc" id="L413">    return readTimeout;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>