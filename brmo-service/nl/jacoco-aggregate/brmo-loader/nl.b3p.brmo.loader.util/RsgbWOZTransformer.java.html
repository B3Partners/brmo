<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="nl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RsgbWOZTransformer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">BRMO service</a> &gt; <a href="../index.html" class="el_bundle">brmo-loader</a> &gt; <a href="index.source.html" class="el_package">nl.b3p.brmo.loader.util</a> &gt; <span class="el_source">RsgbWOZTransformer.java</span></div><h1>RsgbWOZTransformer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2021 B3Partners B.V.
 */
package nl.b3p.brmo.loader.util;

import nl.b3p.brmo.loader.StagingProxy;
import nl.b3p.brmo.loader.entity.Bericht;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.atteo.xmlcombiner.XmlCombiner;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.sql.SQLException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

public class RsgbWOZTransformer extends RsgbTransformer {
<span class="fc" id="L40">    private static final Log LOG = LogFactory.getLog(RsgbWOZTransformer.class);</span>
    private static final String STUF_GEEN_WAARDE = &quot;geenWaarde&quot;;
    private final StagingProxy staging;

    public RsgbWOZTransformer(String pathToXsl, StagingProxy staging)
            throws TransformerConfigurationException, ParserConfigurationException {
<span class="nc" id="L46">        super(pathToXsl);</span>
<span class="nc" id="L47">        this.staging = staging;</span>
<span class="nc" id="L48">    }</span>

    protected static Document merge(String oldDBxml, String newDBxml)
            throws XPathExpressionException, ParserConfigurationException, IOException,
                    SAXException {
        final XPathExpression expression =
<span class="fc" id="L54">                XPathFactory.newInstance().newXPath().compile(&quot;/root/data&quot;);</span>

<span class="fc" id="L56">        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();</span>
        // to prevent XXE
<span class="fc" id="L58">        docBuilderFactory.setExpandEntityReferences(false);</span>
<span class="fc" id="L59">        docBuilderFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span>
<span class="fc" id="L60">        docBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span>
<span class="fc" id="L61">        docBuilderFactory.setIgnoringElementContentWhitespace(true);</span>
<span class="fc" id="L62">        docBuilderFactory.setNamespaceAware(false);</span>

<span class="fc" id="L64">        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();</span>
<span class="fc" id="L65">        Document base = docBuilder.parse(new InputSource(new StringReader(oldDBxml)));</span>

<span class="fc" id="L67">        Element old = (Element) expression.evaluate(base, XPathConstants.NODE);</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">        if (old == null) {</span>
<span class="nc" id="L69">            throw new IOException(oldDBxml + &quot;: expression does not evaluate to node&quot;);</span>
        }
<span class="fc" id="L71">        LOG.trace(&quot;oldDBxml bericht is: &quot; + oldDBxml);</span>
<span class="fc" id="L72">        LOG.trace(&quot;newDBxml bericht is: &quot; + newDBxml);</span>
<span class="fc" id="L73">        Document merge = docBuilder.parse(new InputSource(new StringReader(newDBxml)));</span>

        /*
           (1)Voor elke node in merge, kijk of hij bestaat in base
               zo nee, importeer
               zo ja, kijk of dit het een na diepste niveau is
                   zo ja,
                       ga voor elk childnode na of deze bestaat
                           zo nee, importeer
                           zo ja, overschrijf waarde
                   zo nee, recurse in (1)
        */
<span class="fc" id="L85">        XmlCombiner combiner = new XmlCombiner();</span>
<span class="fc" id="L86">        combiner.combine(base);</span>
<span class="fc" id="L87">        combiner.combine(merge);</span>
<span class="fc" id="L88">        return combiner.buildDocument();</span>
    }

    protected static String print(Document doc) throws TransformerException {
<span class="fc" id="L92">        TransformerFactory transformerFactory = TransformerFactory.newInstance();</span>
        // to prevent XXE
<span class="fc" id="L94">        transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span>
<span class="fc" id="L95">        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span>
<span class="fc" id="L96">        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;&quot;);</span>

<span class="fc" id="L98">        Transformer transformer = transformerFactory.newTransformer();</span>
<span class="fc" id="L99">        transformer.setOutputProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;);</span>
<span class="fc" id="L100">        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, &quot;yes&quot;);</span>
<span class="fc" id="L101">        transformer.setOutputProperty(OutputKeys.INDENT, &quot;no&quot;);</span>
<span class="fc" id="L102">        DOMSource source = new DOMSource(doc);</span>
<span class="fc" id="L103">        StringWriter sw = new StringWriter();</span>
<span class="fc" id="L104">        Result result = new StreamResult(sw);</span>
<span class="fc" id="L105">        transformer.transform(source, result);</span>
<span class="fc" id="L106">        return sw.toString();</span>
    }

    @Override
    public String transformToDbXml(Bericht bericht)
            throws SAXException, IOException, TransformerException {
<span class="nc" id="L112">        String current = super.transformToDbXml(bericht);</span>
<span class="nc" id="L113">        StringBuilder loadLog = new StringBuilder();</span>

<span class="nc" id="L115">        LOG.debug(&quot;actuele bericht is: &quot; + bericht);</span>
        try {
<span class="nc" id="L117">            Bericht previousBericht = staging.getPreviousBericht(bericht, loadLog);</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">            if (previousBericht != null) {</span>
<span class="nc" id="L119">                LOG.debug(&quot;vorige bericht is: &quot; + previousBericht);</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">                if (null == previousBericht.getDbXml()) {</span>
                    // TODO mogelijk op te lossen door previousBericht nogmaals te transformeren via
                    //      oldDBXml = super.transformToDbXml(previousBericht);
                    //      voor nu zetten we de pipelining.enabled op false in de
                    // web.xml/context.xml
                    //      .
                    //      Het probleem is dat het vorige bericht nog in de pipeline kan zitten en
                    // niet committed
                    //      is naar de bericht tabel
<span class="nc" id="L129">                    LOG.warn(&quot;Er is wel een vorig bericht, maar de DB_XML ontbreekt&quot;);</span>
                }
<span class="nc" id="L131">                Document d = merge(previousBericht.getDbXml(), current);</span>

<span class="nc" id="L133">                String mergedDBXML = print(d);</span>
<span class="nc" id="L134">                bericht.setDbXml(mergedDBXML);</span>
<span class="nc" id="L135">                LOG.trace(&quot;mergedDBXML bericht is: &quot; + mergedDBXML);</span>
<span class="nc" id="L136">                current = mergedDBXML;</span>
            }
<span class="nc" id="L138">        } catch (SQLException</span>
                | XPathExpressionException
                | ParserConfigurationException
                | IOException
                | SAXException ex) {
<span class="nc" id="L143">            LOG.error(&quot;Vorige bericht kon niet worden opgehaald: &quot;, ex);</span>
<span class="nc" id="L144">        }</span>
<span class="nc" id="L145">        LOG.debug(loadLog);</span>
<span class="nc" id="L146">        return current;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>