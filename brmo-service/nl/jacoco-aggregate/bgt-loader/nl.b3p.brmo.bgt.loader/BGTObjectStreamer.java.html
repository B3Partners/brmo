<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="nl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>BGTObjectStreamer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">BRMO service</a> &gt; <a href="../index.html" class="el_bundle">bgt-loader</a> &gt; <a href="index.source.html" class="el_package">nl.b3p.brmo.bgt.loader</a> &gt; <span class="el_source">BGTObjectStreamer.java</span></div><h1>BGTObjectStreamer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2021 B3Partners B.V.
 *
 * SPDX-License-Identifier: MIT
 */

package nl.b3p.brmo.bgt.loader;

import static nl.b3p.brmo.bgt.schema.BGTSchema.fixUUID;

import nl.b3p.brmo.bgt.schema.BGTObject;
import nl.b3p.brmo.bgt.schema.BGTObjectType;
import nl.b3p.brmo.bgt.schema.BGTSchema;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.codehaus.staxmate.SMInputFactory;
import org.codehaus.staxmate.in.SMEvent;
import org.codehaus.staxmate.in.SMInputCursor;
import org.geotools.gml.stream.XmlStreamGeometryReader;
import org.locationtech.jts.geom.Geometry;
import org.opengis.referencing.FactoryException;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;

import javax.xml.namespace.QName;
import javax.xml.stream.Location;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;

public class BGTObjectStreamer implements Iterable&lt;BGTObject&gt; {
<span class="fc" id="L44">    private static final Log log = LogFactory.getLog(BGTObjectStreamer.class);</span>

    private static final String NS_IMGEO = &quot;http://www.geostandaarden.nl/imgeo/2.1&quot;;
    private static final String NS_CITYGML = &quot;http://www.opengis.net/citygml/2.0&quot;;
    private static final String NS_GML = &quot;http://www.opengis.net/gml&quot;;
    private static final String NS_MUTATIELEVERING =
            &quot;http://www.kadaster.nl/schemas/mutatielevering-generiek/2.0&quot;;
    private static final String NS_MUTATIELEVERING_BGT =
            &quot;http://www.kadaster.nl/schemas/mutatielevering-bgt/1.0&quot;;

<span class="fc" id="L54">    private static final QName CITYGML_CITY_OBJECT_MEMBER =</span>
            new QName(NS_CITYGML, &quot;cityObjectMember&quot;);
<span class="fc" id="L56">    private static final QName CITYGML_CITY_MODEL = new QName(NS_CITYGML, &quot;CityModel&quot;);</span>

<span class="fc" id="L58">    private static final QName MUTATIE_BERICHT = new QName(NS_MUTATIELEVERING, &quot;mutatieBericht&quot;);</span>

<span class="fc" id="L60">    private static final QName BGT_MUTATIES = new QName(NS_MUTATIELEVERING_BGT, &quot;bgtMutaties&quot;);</span>
<span class="fc" id="L61">    private static final QName BGT_OBJECT = new QName(NS_MUTATIELEVERING_BGT, &quot;bgtObject&quot;);</span>

<span class="fc" id="L63">    private static final QName LOKAAL_ID = new QName(NS_IMGEO, &quot;lokaalID&quot;);</span>

    private static final int SRID = 28992;

    private final XmlStreamGeometryReader geometryReader;

    private final SMInputCursor cursor;

    private boolean isMutaties;
<span class="pc" id="L72">    private boolean hasMutatieGroep = false;</span>

    private MutatieInhoud mutatieInhoud;

<span class="fc" id="L76">    public static class MutatieInhoud {</span>
        private String mutatieType;
        private String gebied;
        private String leveringsId;
<span class="fc" id="L80">        private final List&lt;String&gt; objectTypen = new ArrayList&lt;&gt;();</span>

        public String getMutatieType() {
<span class="fc" id="L83">            return mutatieType;</span>
        }

        public String getGebied() {
<span class="fc" id="L87">            return gebied;</span>
        }

        public String getLeveringsId() {
<span class="fc" id="L91">            return leveringsId;</span>
        }

        public List&lt;String&gt; getObjectTypen() {
<span class="fc" id="L95">            return objectTypen;</span>
        }
    }

    public MutatieInhoud getMutatieInhoud() {
<span class="fc" id="L100">        return mutatieInhoud;</span>
    }

<span class="nc" id="L103">    public BGTObjectStreamer(File f) throws XMLStreamException {</span>
<span class="nc" id="L104">        this.cursor = initCursor(buildSMInputFactory().rootElementCursor(f));</span>
<span class="nc" id="L105">        this.geometryReader = buildGeometryReader();</span>
<span class="nc" id="L106">    }</span>

<span class="fc" id="L108">    public BGTObjectStreamer(InputStream in) throws XMLStreamException {</span>
<span class="fc" id="L109">        this.cursor = initCursor(buildSMInputFactory().rootElementCursor(in));</span>
<span class="fc" id="L110">        this.geometryReader = buildGeometryReader();</span>
<span class="fc" id="L111">    }</span>

<span class="nc" id="L113">    public BGTObjectStreamer(Reader r) throws XMLStreamException {</span>
<span class="nc" id="L114">        this.cursor = initCursor(buildSMInputFactory().rootElementCursor(r));</span>
<span class="nc" id="L115">        this.geometryReader = buildGeometryReader();</span>
<span class="nc" id="L116">    }</span>

    private SMInputCursor initCursor(SMInputCursor cursor) throws XMLStreamException {
<span class="fc" id="L119">        QName root = cursor.advance().getQName();</span>

<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (root.equals(CITYGML_CITY_MODEL)) {</span>
<span class="fc" id="L122">            isMutaties = false;</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        } else if (root.equals(BGT_MUTATIES)) {</span>
<span class="fc" id="L124">            isMutaties = true;</span>
        } else {
<span class="nc" id="L126">            throw new IllegalArgumentException(</span>
                    &quot;XML root element moet CityModel of bgtMutaties zijn&quot;);
        }

        // Note: when using StaxMate childElementCursor() or similar, only an local name string
        // element does not work
        // when using Aalto. Always use a QName parameter!

<span class="fc bfc" id="L134" title="All 2 branches covered.">        if (isMutaties) {</span>
<span class="fc" id="L135">            cursor =</span>
<span class="fc" id="L136">                    cursor.childElementCursor(MUTATIE_BERICHT)</span>
<span class="fc" id="L137">                            .advance()</span>
<span class="fc" id="L138">                            .childElementCursor()</span>
<span class="fc" id="L139">                            .advance();</span>
            label:
            do {
<span class="pc bpc" id="L142" title="1 of 4 branches missed.">                switch (cursor.getLocalName()) {</span>
                    case &quot;dataset&quot;:
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">                        assert cursor.collectDescendantText().equals(&quot;bgt&quot;);</span>
                        break;
                    case &quot;inhoud&quot;:
<span class="fc" id="L147">                        this.mutatieInhoud = parseInhoud(cursor);</span>
<span class="fc" id="L148">                        break;</span>
                    case &quot;mutatieGroep&quot;:
                        // cursor positioned correctly
<span class="fc" id="L151">                        hasMutatieGroep = true;</span>
<span class="fc" id="L152">                        break label;</span>
                    default:
<span class="nc" id="L154">                        throw new IllegalStateException(</span>
<span class="nc" id="L155">                                &quot;Verwacht mutatieGroep element, gevonden &quot; + cursor.getQName());</span>
                }
<span class="fc bfc" id="L157" title="All 2 branches covered.">            } while (cursor.getNext() != null);</span>

        } else {
<span class="fc" id="L160">            cursor = cursor.childElementCursor(CITYGML_CITY_OBJECT_MEMBER).advance();</span>
        }

<span class="fc" id="L163">        return cursor;</span>
    }

    private static MutatieInhoud parseInhoud(SMInputCursor inhoudCursor) throws XMLStreamException {
<span class="fc" id="L167">        SMInputCursor cursor = inhoudCursor.childElementCursor();</span>
<span class="fc" id="L168">        MutatieInhoud mutatieInhoud = new MutatieInhoud();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        while (cursor.getNext() != null) {</span>
<span class="pc bpc" id="L170" title="1 of 5 branches missed.">            switch (cursor.getLocalName()) {</span>
                case &quot;mutatieType&quot;:
<span class="fc" id="L172">                    mutatieInhoud.mutatieType = cursor.collectDescendantText().trim();</span>
<span class="fc" id="L173">                    break;</span>
                case &quot;gebied&quot;:
<span class="fc" id="L175">                    mutatieInhoud.gebied = cursor.collectDescendantText().trim();</span>
<span class="fc" id="L176">                    break;</span>
                case &quot;leveringsId&quot;:
<span class="fc" id="L178">                    mutatieInhoud.leveringsId = cursor.collectDescendantText().trim();</span>
<span class="fc" id="L179">                    break;</span>
                case &quot;objectTypen&quot;:
<span class="fc" id="L181">                    SMInputCursor c = cursor.childElementCursor();</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">                    while (c.getNext() != null) {</span>
<span class="fc" id="L183">                        mutatieInhoud.objectTypen.add(c.collectDescendantText().trim());</span>
                    }
<span class="fc" id="L185">                    break;</span>
            }
        }
<span class="fc" id="L188">        return mutatieInhoud;</span>
    }

    protected XmlStreamGeometryReader buildGeometryReader() {
<span class="fc" id="L192">        return new XmlStreamGeometryReader(this.cursor.getStreamReader());</span>
    }

    protected SMInputFactory buildSMInputFactory() {
        // Using alternative StAX parsers explicitly:
        // final XMLInputFactory stax = new WstxInputFactory(); // Woodstox
        // final XMLInputFactory stax = new com.fasterxml.aalto.stax.InputFactoryImpl(); // Aalto
        final XMLInputFactory xmlInputFactory =
<span class="fc" id="L200">                XMLInputFactory.newFactory(); // JRE Default, depends on JAR's present or</span>
        // javax.xml.stream.XMLInputFactory property, can be SJSXP
<span class="fc" id="L202">        log.trace(&quot;StAX XMLInputFactory: &quot; + xmlInputFactory.getClass().getName());</span>

<span class="fc" id="L204">        xmlInputFactory.setProperty(</span>
                XMLInputFactory.IS_COALESCING, Boolean.TRUE); // Coalesce characters
<span class="fc" id="L206">        xmlInputFactory.setProperty(</span>
                XMLInputFactory.SUPPORT_DTD,
                Boolean.FALSE); // No XML entity expansions or external entities

<span class="fc" id="L210">        return new SMInputFactory(xmlInputFactory);</span>
    }

    @Override
    public Iterator&lt;BGTObject&gt; iterator() {
<span class="fc" id="L215">        return new Iterator&lt;&gt;() {</span>
<span class="fc" id="L216">            SMEvent event = cursor.getCurrEvent();</span>

            /**
             * A parse action may return multiple objects. Buffer the future objects to be returned
             * in a next() call.
             */
<span class="fc" id="L222">            private final Queue&lt;BGTObject&gt; buffer = new LinkedList&lt;&gt;();</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L226" title="All 4 branches covered.">                if (isMutaties &amp;&amp; !hasMutatieGroep) {</span>
<span class="fc" id="L227">                    return false;</span>
                }
<span class="fc bfc" id="L229" title="All 2 branches covered.">                if (!buffer.isEmpty()) {</span>
<span class="fc" id="L230">                    return true;</span>
                }
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">                if (event != null) {</span>
<span class="nc" id="L233">                    return true;</span>
                }
                try {
<span class="fc" id="L236">                    event = cursor.getNext();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">                    return event != null;</span>
<span class="nc" id="L238">                } catch (XMLStreamException e) {</span>
<span class="nc" id="L239">                    throw new RuntimeException(e);</span>
                }
            }

            @Override
            public BGTObject next() {
                try {
<span class="fc bfc" id="L246" title="All 2 branches covered.">                    if (!buffer.isEmpty()) {</span>
<span class="fc" id="L247">                        return buffer.remove();</span>
                    }
<span class="pc bpc" id="L249" title="1 of 4 branches missed.">                    if (isMutaties &amp;&amp; !hasMutatieGroep) {</span>
<span class="nc" id="L250">                        throw new IllegalStateException(&quot;No items&quot;);</span>
                    }
<span class="fc bfc" id="L252" title="All 2 branches covered.">                    if (event == null) {</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">                        if (!hasNext()) {</span>
<span class="nc" id="L254">                            throw new IllegalStateException(&quot;No more items&quot;);</span>
                        }
                    }
                    // Make sure cityObjectMembers.getNext() is called with next Iterator.getNext()
                    // call
<span class="fc" id="L259">                    event = null;</span>

<span class="fc" id="L261">                    Map&lt;String, Object&gt; attributes = new HashMap&lt;&gt;();</span>

                    SMInputCursor cityObjectMemberChild;

<span class="fc" id="L265">                    String gmlIdPreviousVersion = null;</span>
<span class="fc" id="L266">                    BGTObject.MutatieStatus mutatieStatus = BGTObject.MutatieStatus.WORDT;</span>

<span class="fc bfc" id="L268" title="All 2 branches covered.">                    if (isMutaties) {</span>
                        // Assume single child per &lt;mutatieGroep&gt;, cursor is currently at
                        // &lt;mutatieGroep&gt;

<span class="fc" id="L272">                        SMInputCursor mutatie = cursor.childElementCursor().advance();</span>
<span class="fc" id="L273">                        String mutatieNaam = mutatie.getLocalName();</span>
<span class="pc bpc" id="L274" title="1 of 4 branches missed.">                        if (mutatieNaam.equals(&quot;wijziging&quot;) || mutatieNaam.equals(&quot;toevoeging&quot;)) {</span>
<span class="fc" id="L275">                            mutatie = mutatie.childElementCursor().advance();</span>
                        } else {
<span class="nc" id="L277">                            throw new IllegalStateException(</span>
<span class="nc" id="L278">                                    &quot;Ongeldig mutatieGroep child element: &quot; + mutatie.getQName());</span>
                        }

<span class="fc bfc" id="L281" title="All 2 branches covered.">                        if (mutatieNaam.equals(&quot;wijziging&quot;)) {</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">                            assert mutatie.getLocalName().equals(&quot;was&quot;);</span>
<span class="fc" id="L283">                            gmlIdPreviousVersion = fixUUID(mutatie.getAttrValue(&quot;id&quot;));</span>

<span class="pc bpc" id="L285" title="1 of 2 branches missed.">                            if (mutatie.getNext() == null) {</span>
                                // To support deletes, we would need to parse the &lt;cityObjectMember&gt;
                                // child element name
                                // at least, but deletes do not occur for bgt
<span class="nc" id="L289">                                throw new IllegalStateException(</span>
                                        &quot;Mutaties 'was' zonder 'wordt' worden niet ondersteund voor BGT&quot;);
                            }
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">                            assert mutatie.getLocalName().equals(&quot;wordt&quot;);</span>
<span class="fc" id="L293">                            mutatieStatus = BGTObject.MutatieStatus.WAS_WORDT;</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">                        } else if (mutatieNaam.equals(&quot;toevoeging&quot;)) {</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">                            assert mutatie.getLocalName().equals(&quot;wordt&quot;);</span>
                            // mutatieStatus is already IMGeoObject.MutatieStatus.WORDT
                        } else {
<span class="nc" id="L298">                            throw new IllegalStateException(</span>
<span class="nc" id="L299">                                    &quot;Ongeldig mutatie element: &quot; + mutatie.getLocalName());</span>
                        }

                        // Move cursor from &lt;wordt&gt; to &lt;cityObjectMember&gt; child
<span class="fc" id="L303">                        cityObjectMemberChild =</span>
<span class="fc" id="L304">                                mutatie.childElementCursor(BGT_OBJECT)</span>
<span class="fc" id="L305">                                        .advance()</span>
<span class="fc" id="L306">                                        .childElementCursor(CITYGML_CITY_OBJECT_MEMBER)</span>
<span class="fc" id="L307">                                        .advance()</span>
<span class="fc" id="L308">                                        .childElementCursor()</span>
<span class="fc" id="L309">                                        .advance();</span>
<span class="fc" id="L310">                    } else {</span>
<span class="fc" id="L311">                        cityObjectMemberChild = cursor.childElementCursor().advance();</span>
                    }

<span class="fc" id="L314">                    final String name = cityObjectMemberChild.getLocalName();</span>
                    final BGTObjectType bgtObjectType =
<span class="fc" id="L316">                            BGTSchema.getInstance().getObjectTypeByName(name);</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">                    if (bgtObjectType == null) {</span>
<span class="nc" id="L318">                        throw new IllegalArgumentException(&quot;Onbekend object type: &quot; + name);</span>
                    }
<span class="fc" id="L320">                    final Location location = cityObjectMemberChild.getCursorLocation();</span>
<span class="fc" id="L321">                    attributes.put(</span>
<span class="fc" id="L322">                            &quot;gmlId&quot;, fixUUID(cityObjectMemberChild.getAttrValue(NS_GML, &quot;id&quot;)));</span>

<span class="fc" id="L324">                    SMInputCursor attributesCursor = cityObjectMemberChild.childElementCursor();</span>

                    // Only a single collection attribute is supported (no matrix of multiple
                    // collection attributes)
                    // An IMGeoObject will be returned for each collection item
<span class="fc" id="L329">                    Collection&lt;Map&lt;String, Object&gt;&gt; collectionAttribute = null;</span>

<span class="fc bfc" id="L331" title="All 2 branches covered.">                    while (attributesCursor.getNext() != null) {</span>
<span class="fc" id="L332">                        String attributeName = attributesCursor.getLocalName();</span>
<span class="fc" id="L333">                        Object parsedAttribute = parseIMGeoAttribute(attributesCursor);</span>

<span class="fc bfc" id="L335" title="All 2 branches covered.">                        if (parsedAttribute instanceof BGTObject) {</span>
<span class="fc" id="L336">                            List&lt;BGTObject&gt; oneToMany =</span>
<span class="fc" id="L337">                                    (List&lt;BGTObject&gt;) attributes.get(attributeName);</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">                            if (oneToMany == null) {</span>
<span class="fc" id="L339">                                oneToMany = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L340">                                attributes.put(attributeName, oneToMany);</span>
                            }
<span class="fc" id="L342">                            oneToMany.add((BGTObject) parsedAttribute);</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">                        } else if (parsedAttribute instanceof Collection) {</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">                            if (collectionAttribute != null) {</span>
<span class="nc" id="L345">                                throw new IllegalStateException(</span>
                                        &quot;Only a single collection attribute is supported&quot;);
                            }
<span class="fc" id="L348">                            collectionAttribute = (Collection&lt;Map&lt;String, Object&gt;&gt;) parsedAttribute;</span>
                        } else {
<span class="fc" id="L350">                            attributes.put(attributeName, parsedAttribute);</span>
                        }
<span class="fc" id="L352">                    }</span>

<span class="pc bpc" id="L354" title="1 of 4 branches missed.">                    if (collectionAttribute != null &amp;&amp; !collectionAttribute.isEmpty()) {</span>
<span class="fc" id="L355">                        int index = 0;</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">                        for (Map&lt;String, Object&gt; collectionItem : collectionAttribute) {</span>
<span class="fc" id="L357">                            Map&lt;String, Object&gt; attributesForCollectionItem =</span>
                                    new HashMap&lt;&gt;(attributes);
<span class="fc" id="L359">                            attributesForCollectionItem.putAll(collectionItem);</span>
<span class="fc" id="L360">                            attributesForCollectionItem.put(BGTSchema.INDEX, index++);</span>
<span class="fc" id="L361">                            buffer.add(</span>
                                    new BGTObject(
                                            bgtObjectType, attributesForCollectionItem, location));
<span class="fc" id="L364">                        }</span>
<span class="fc" id="L365">                        return buffer.remove();</span>
                    } else {
<span class="fc" id="L367">                        return new BGTObject(</span>
                                bgtObjectType,
                                attributes,
                                location,
                                mutatieStatus,
                                gmlIdPreviousVersion);
                    }
<span class="nc" id="L374">                } catch (Exception e) {</span>
<span class="nc" id="L375">                    throw new RuntimeException(e);</span>
                }
            }
        };
    }

    private Object parseIMGeoAttribute(SMInputCursor attribute)
            throws XMLStreamException, FactoryException, IOException {
<span class="fc" id="L383">        if (&quot;true&quot;</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">                .equals(</span>
<span class="fc" id="L385">                        attribute.getAttrValue(</span>
                                &quot;http://www.w3.org/2001/XMLSchema-instance&quot;, &quot;nil&quot;))) {
<span class="nc" id="L387">            return null;</span>
        }

<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (attribute.hasLocalName(&quot;identificatie&quot;)) {</span>
            /*
            &lt;imgeo:identificatie&gt;
                &lt;imgeo:NEN3610ID&gt;
                    &lt;imgeo:namespace&gt;NL.IMGeo&lt;/imgeo:namespace&gt;
                    &lt;imgeo:lokaalID&gt;G1234.abcdef01234567890abcdef012345678&lt;/imgeo:lokaalID&gt;
                &lt;/imgeo:NEN3610ID&gt;
            &lt;/imgeo:identificatie&gt;
             */
            // Just get the UUID
<span class="fc" id="L400">            String id =</span>
                    attribute
<span class="fc" id="L402">                            .descendantElementCursor(LOKAAL_ID)</span>
<span class="fc" id="L403">                            .advance()</span>
<span class="fc" id="L404">                            .collectDescendantText()</span>
<span class="fc" id="L405">                            .trim();</span>
            // UUID is allowed to have '-' characters, normalize it to UUID without
<span class="fc" id="L407">            return id.replaceAll(&quot;-&quot;, &quot;&quot;);</span>
        }

<span class="fc bfc" id="L410" title="All 2 branches covered.">        if (isGeometryElement(attribute.getLocalName())) {</span>
            // Position underlying XmlStreamReader at GML element
<span class="fc" id="L412">            attribute.childElementCursor().advance();</span>

<span class="fc" id="L414">            Geometry geom = geometryReader.readGeometry();</span>
<span class="fc" id="L415">            geom.setSRID(SRID);</span>
<span class="fc" id="L416">            return geom;</span>
        }

<span class="fc bfc" id="L419" title="All 2 branches covered.">        if (attribute.hasLocalName(&quot;nummeraanduidingreeks&quot;)) {</span>
<span class="fc" id="L420">            Location location = attribute.getCursorLocation();</span>
<span class="fc" id="L421">            Map&lt;String, Object&gt; nummeraanduidingreeks = parseNummeraanduidingreeks(attribute);</span>
<span class="fc" id="L422">            return new BGTObject(</span>
<span class="fc" id="L423">                    BGTSchema.getInstance().getObjectTypeByName(&quot;nummeraanduidingreeks&quot;),</span>
                    nummeraanduidingreeks,
                    location);
        }

<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (attribute.hasLocalName(&quot;openbareRuimteNaam&quot;)) {</span>
<span class="fc" id="L429">            return parseOpenbareRuimteNaam(attribute);</span>
        }

        // String attribute value as default
<span class="fc" id="L433">        return attribute.collectDescendantText().trim();</span>
    }

    private static boolean isGeometryElement(String localName) {
<span class="pc bpc" id="L437" title="1 of 4 branches missed.">        return localName.startsWith(&quot;geometrie&quot;) || localName.startsWith(&quot;kruinlijn&quot;);</span>
    }

<span class="fc" id="L440">    private static final QName CAPITALIZED_NUMMERAANDUIDINGREEKS =</span>
            new QName(NS_IMGEO, &quot;Nummeraanduidingreeks&quot;);
<span class="fc" id="L442">    private static final QName LOWERCASE_NUMMERAANDUIDINGREEKS =</span>
            new QName(NS_IMGEO, &quot;nummeraanduidingreeks&quot;);
<span class="fc" id="L444">    private static final QName LABEL = new QName(NS_IMGEO, &quot;Label&quot;);</span>
<span class="fc" id="L445">    private static final QName LABELPOSITIE = new QName(NS_IMGEO, &quot;Labelpositie&quot;);</span>

    private Map&lt;String, Object&gt; parseNummeraanduidingreeks(SMInputCursor cursor)
            throws XMLStreamException, FactoryException, IOException {
<span class="fc" id="L449">        Map&lt;String, Object&gt; label = new HashMap&lt;&gt;();</span>

<span class="fc" id="L451">        cursor =</span>
<span class="fc" id="L452">                cursor.childElementCursor(CAPITALIZED_NUMMERAANDUIDINGREEKS)</span>
<span class="fc" id="L453">                        .advance()</span>
<span class="fc" id="L454">                        .childElementCursor();</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">        while (cursor.getNext() != null) {</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">            if (cursor.getQName().equals(LOWERCASE_NUMMERAANDUIDINGREEKS)) {</span>
<span class="fc" id="L457">                SMInputCursor labelChilds =</span>
<span class="fc" id="L458">                        cursor.childElementCursor(LABEL).advance().childElementCursor();</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">                while (labelChilds.getNext() != null) {</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">                    if (labelChilds.hasLocalName(&quot;tekst&quot;)) {</span>
<span class="fc" id="L461">                        label.put(&quot;tekst&quot;, labelChilds.collectDescendantText().trim());</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">                    } else if (labelChilds.hasLocalName(&quot;positie&quot;)) {</span>
<span class="fc" id="L463">                        SMInputCursor labelPositie =</span>
<span class="fc" id="L464">                                labelChilds.childElementCursor(LABELPOSITIE).advance();</span>

<span class="fc" id="L466">                        SMInputCursor labelPositieChilds = labelPositie.childElementCursor();</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">                        while (labelPositieChilds.getNext() != null) {</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">                            if (labelPositieChilds.hasLocalName(&quot;plaatsingspunt&quot;)) {</span>
                                // Positioneer op &lt;gml:Point/&gt;
<span class="fc" id="L470">                                labelPositieChilds.childElementCursor().advance();</span>
<span class="fc" id="L471">                                labelPositieChilds</span>
<span class="fc" id="L472">                                        .getStreamReader()</span>
<span class="fc" id="L473">                                        .require(XMLStreamConstants.START_ELEMENT, NS_GML, &quot;Point&quot;);</span>
<span class="fc" id="L474">                                Geometry geom = geometryReader.readGeometry();</span>
<span class="fc" id="L475">                                geom.setSRID(SRID);</span>
<span class="fc" id="L476">                                label.put(&quot;plaatsingspunt&quot;, geom);</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">                            } else if (labelPositieChilds.hasLocalName(&quot;hoek&quot;)) {</span>
<span class="fc" id="L478">                                String hoek = labelPositieChilds.collectDescendantText().trim();</span>
<span class="fc" id="L479">                                label.put(&quot;hoek&quot;, Double.parseDouble(hoek));</span>
<span class="fc" id="L480">                            }</span>
                        }
<span class="fc" id="L482">                    }</span>
                }
<span class="fc" id="L484">            } else {</span>
<span class="fc" id="L485">                label.put(cursor.getLocalName(), cursor.collectDescendantText().trim());</span>
            }
        }

<span class="fc" id="L489">        return label;</span>
    }

    private List&lt;Map&lt;String, Object&gt;&gt; parseOpenbareRuimteNaam(SMInputCursor cursor)
            throws XMLStreamException, FactoryException, IOException {

<span class="fc" id="L495">        cursor = cursor.childElementCursor(LABEL).advance().childElementCursor();</span>

<span class="fc" id="L497">        List&lt;Map&lt;String, Object&gt;&gt; posities = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L498">        String tekst = null;</span>

<span class="fc bfc" id="L500" title="All 2 branches covered.">        while (cursor.getNext() != null) {</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">            if (cursor.getLocalName().equals(&quot;tekst&quot;)) {</span>
<span class="fc" id="L502">                tekst = cursor.collectDescendantText().trim();</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">            } else if (cursor.getLocalName().equals(&quot;positie&quot;)) {</span>
<span class="fc" id="L504">                Map&lt;String, Object&gt; positie = new HashMap&lt;&gt;();</span>
<span class="fc" id="L505">                positie.put(&quot;tekst&quot;, tekst);</span>
<span class="fc" id="L506">                posities.add(positie);</span>
<span class="fc" id="L507">                SMInputCursor positieCursor =</span>
<span class="fc" id="L508">                        cursor.childElementCursor().advance().childElementCursor();</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">                while (positieCursor.getNext() != null) {</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">                    if (positieCursor.getLocalName().equals(&quot;plaatsingspunt&quot;)) {</span>
<span class="fc" id="L511">                        positieCursor.childElementCursor().advance();</span>
<span class="fc" id="L512">                        Geometry geom = geometryReader.readGeometry();</span>
<span class="fc" id="L513">                        geom.setSRID(SRID);</span>
<span class="fc" id="L514">                        positie.put(&quot;plaatsingspunt&quot;, geom);</span>
<span class="fc" id="L515">                    } else {</span>
<span class="fc" id="L516">                        positie.put(</span>
<span class="fc" id="L517">                                positieCursor.getLocalName(),</span>
<span class="fc" id="L518">                                positieCursor.collectDescendantText().trim());</span>
                    }
                }
<span class="fc" id="L521">            }</span>
        }

<span class="fc" id="L524">        return posities;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>