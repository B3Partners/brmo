<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ApiClient.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">BRMO service</a> &gt; <a href="../index.html" class="el_bundle">bgt-loader</a> &gt; <a href="index.source.html" class="el_package">nl.b3p.brmo.bgt.download.client</a> &gt; <span class="el_source">ApiClient.java</span></div><h1>ApiClient.java</h1><pre class="source lang-java linenums">/*
 * BGT Download API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package nl.b3p.brmo.bgt.download.client;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import java.io.InputStream;
import java.net.URI;
import java.net.URLEncoder;
import java.net.http.HttpClient;
import java.net.http.HttpConnectTimeoutException;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.StringJoiner;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * Configuration and utility class for API clients.
 *
 * &lt;p&gt;This class can be constructed and modified, then used to instantiate the
 * various API classes. The API classes use the settings in this class to
 * configure themselves, but otherwise do not store a link to this class.&lt;/p&gt;
 *
 * &lt;p&gt;This class is mutable and not synchronized, so it is not thread-safe.
 * The API classes generated from this are immutable and thread-safe.&lt;/p&gt;
 *
 * &lt;p&gt;The setter methods of this class return the current object to facilitate
 * a fluent style of configuration.&lt;/p&gt;
 */
@javax.annotation.Generated(value = &quot;org.openapitools.codegen.languages.JavaClientCodegen&quot;, comments = &quot;Generator version: 7.10.0&quot;)
public class ApiClient {

  private HttpClient.Builder builder;
  private ObjectMapper mapper;
  private String scheme;
  private String host;
  private int port;
  private String basePath;
  private Consumer&lt;HttpRequest.Builder&gt; interceptor;
  private Consumer&lt;HttpResponse&lt;InputStream&gt;&gt; responseInterceptor;
  private Consumer&lt;HttpResponse&lt;String&gt;&gt; asyncResponseInterceptor;
  private Duration readTimeout;
  private Duration connectTimeout;

  public static String valueToString(Object value) {
<span class="nc bnc" id="L69" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L70">      return &quot;&quot;;</span>
    }
<span class="nc bnc" id="L72" title="All 2 branches missed.">    if (value instanceof OffsetDateTime) {</span>
<span class="nc" id="L73">      return ((OffsetDateTime) value).format(DateTimeFormatter.ISO_OFFSET_DATE_TIME);</span>
    }
<span class="nc" id="L75">    return value.toString();</span>
  }

  /**
   * URL encode a string in the UTF-8 encoding.
   *
   * @param s String to encode.
   * @return URL-encoded representation of the input string.
   */
  public static String urlEncode(String s) {
<span class="nc" id="L85">    return URLEncoder.encode(s, UTF_8).replaceAll(&quot;\\+&quot;, &quot;%20&quot;);</span>
  }

  /**
   * Convert a URL query name/value parameter to a list of encoded {@link Pair}
   * objects.
   *
   * &lt;p&gt;The value can be null, in which case an empty list is returned.&lt;/p&gt;
   *
   * @param name The query name parameter.
   * @param value The query value, which may not be a collection but may be
   *              null.
   * @return A singleton list of the {@link Pair} objects representing the input
   * parameters, which is encoded for use in a URL. If the value is null, an
   * empty list is returned.
   */
  public static List&lt;Pair&gt; parameterToPairs(String name, Object value) {
<span class="nc bnc" id="L102" title="All 6 branches missed.">    if (name == null || name.isEmpty() || value == null) {</span>
<span class="nc" id="L103">      return Collections.emptyList();</span>
    }
<span class="nc" id="L105">    return Collections.singletonList(new Pair(urlEncode(name), urlEncode(valueToString(value))));</span>
  }

  /**
   * Convert a URL query name/collection parameter to a list of encoded
   * {@link Pair} objects.
   *
   * @param collectionFormat The swagger collectionFormat string (csv, tsv, etc).
   * @param name The query name parameter.
   * @param values A collection of values for the given query name, which may be
   *               null.
   * @return A list of {@link Pair} objects representing the input parameters,
   * which is encoded for use in a URL. If the values collection is null, an
   * empty list is returned.
   */
  public static List&lt;Pair&gt; parameterToPairs(
      String collectionFormat, String name, Collection&lt;?&gt; values) {
<span class="nc bnc" id="L122" title="All 8 branches missed.">    if (name == null || name.isEmpty() || values == null || values.isEmpty()) {</span>
<span class="nc" id="L123">      return Collections.emptyList();</span>
    }

    // get the collection format (default: csv)
<span class="nc bnc" id="L127" title="All 4 branches missed.">    String format = collectionFormat == null || collectionFormat.isEmpty() ? &quot;csv&quot; : collectionFormat;</span>

    // create the params based on the collection format
<span class="nc bnc" id="L130" title="All 2 branches missed.">    if (&quot;multi&quot;.equals(format)) {</span>
<span class="nc" id="L131">      return values.stream()</span>
<span class="nc" id="L132">          .map(value -&gt; new Pair(urlEncode(name), urlEncode(valueToString(value))))</span>
<span class="nc" id="L133">          .collect(Collectors.toList());</span>
    }

    String delimiter;
<span class="nc bnc" id="L137" title="All 5 branches missed.">    switch(format) {</span>
      case &quot;csv&quot;:
<span class="nc" id="L139">        delimiter = urlEncode(&quot;,&quot;);</span>
<span class="nc" id="L140">        break;</span>
      case &quot;ssv&quot;:
<span class="nc" id="L142">        delimiter = urlEncode(&quot; &quot;);</span>
<span class="nc" id="L143">        break;</span>
      case &quot;tsv&quot;:
<span class="nc" id="L145">        delimiter = urlEncode(&quot;\t&quot;);</span>
<span class="nc" id="L146">        break;</span>
      case &quot;pipes&quot;:
<span class="nc" id="L148">        delimiter = urlEncode(&quot;|&quot;);</span>
<span class="nc" id="L149">        break;</span>
      default:
<span class="nc" id="L151">        throw new IllegalArgumentException(&quot;Illegal collection format: &quot; + collectionFormat);</span>
    }

<span class="nc" id="L154">    StringJoiner joiner = new StringJoiner(delimiter);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">    for (Object value : values) {</span>
<span class="nc" id="L156">      joiner.add(urlEncode(valueToString(value)));</span>
<span class="nc" id="L157">    }</span>

<span class="nc" id="L159">    return Collections.singletonList(new Pair(urlEncode(name), joiner.toString()));</span>
  }

  /**
   * Create an instance of ApiClient.
   */
<span class="nc" id="L165">  public ApiClient() {</span>
<span class="nc" id="L166">    this.builder = createDefaultHttpClientBuilder();</span>
<span class="nc" id="L167">    this.mapper = createDefaultObjectMapper();</span>
<span class="nc" id="L168">    updateBaseUri(getDefaultBaseUri());</span>
<span class="nc" id="L169">    interceptor = null;</span>
<span class="nc" id="L170">    readTimeout = null;</span>
<span class="nc" id="L171">    connectTimeout = null;</span>
<span class="nc" id="L172">    responseInterceptor = null;</span>
<span class="nc" id="L173">    asyncResponseInterceptor = null;</span>
<span class="nc" id="L174">  }</span>

  /**
   * Create an instance of ApiClient.
   *
   * @param builder Http client builder.
   * @param mapper Object mapper.
   * @param baseUri Base URI
   */
<span class="nc" id="L183">  public ApiClient(HttpClient.Builder builder, ObjectMapper mapper, String baseUri) {</span>
<span class="nc" id="L184">    this.builder = builder;</span>
<span class="nc" id="L185">    this.mapper = mapper;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">    updateBaseUri(baseUri != null ? baseUri : getDefaultBaseUri());</span>
<span class="nc" id="L187">    interceptor = null;</span>
<span class="nc" id="L188">    readTimeout = null;</span>
<span class="nc" id="L189">    connectTimeout = null;</span>
<span class="nc" id="L190">    responseInterceptor = null;</span>
<span class="nc" id="L191">    asyncResponseInterceptor = null;</span>
<span class="nc" id="L192">  }</span>

  protected ObjectMapper createDefaultObjectMapper() {
<span class="nc" id="L195">    ObjectMapper mapper = new ObjectMapper();</span>
<span class="nc" id="L196">    mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span>
<span class="nc" id="L197">    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);</span>
<span class="nc" id="L198">    mapper.configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false);</span>
<span class="nc" id="L199">    mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span>
<span class="nc" id="L200">    mapper.enable(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);</span>
<span class="nc" id="L201">    mapper.enable(DeserializationFeature.READ_ENUMS_USING_TO_STRING);</span>
<span class="nc" id="L202">    mapper.disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);</span>
<span class="nc" id="L203">    mapper.registerModule(new JavaTimeModule());</span>
<span class="nc" id="L204">    return mapper;</span>
  }

  protected String getDefaultBaseUri() {
<span class="nc" id="L208">    return &quot;https://api.pdok.nl/lv/bgt/download/v1_0&quot;;</span>
  }

  protected HttpClient.Builder createDefaultHttpClientBuilder() {
<span class="nc" id="L212">    return HttpClient.newBuilder();</span>
  }

  public void updateBaseUri(String baseUri) {
<span class="nc" id="L216">    URI uri = URI.create(baseUri);</span>
<span class="nc" id="L217">    scheme = uri.getScheme();</span>
<span class="nc" id="L218">    host = uri.getHost();</span>
<span class="nc" id="L219">    port = uri.getPort();</span>
<span class="nc" id="L220">    basePath = uri.getRawPath();</span>
<span class="nc" id="L221">  }</span>

  /**
   * Set a custom {@link HttpClient.Builder} object to use when creating the
   * {@link HttpClient} that is used by the API client.
   *
   * @param builder Custom client builder.
   * @return This object.
   */
  public ApiClient setHttpClientBuilder(HttpClient.Builder builder) {
<span class="nc" id="L231">    this.builder = builder;</span>
<span class="nc" id="L232">    return this;</span>
  }

  /**
   * Get an {@link HttpClient} based on the current {@link HttpClient.Builder}.
   *
   * &lt;p&gt;The returned object is immutable and thread-safe.&lt;/p&gt;
   *
   * @return The HTTP client.
   */
  public HttpClient getHttpClient() {
<span class="nc" id="L243">    return builder.build();</span>
  }

  /**
   * Set a custom {@link ObjectMapper} to serialize and deserialize the request
   * and response bodies.
   *
   * @param mapper Custom object mapper.
   * @return This object.
   */
  public ApiClient setObjectMapper(ObjectMapper mapper) {
<span class="nc" id="L254">    this.mapper = mapper;</span>
<span class="nc" id="L255">    return this;</span>
  }

  /**
   * Get a copy of the current {@link ObjectMapper}.
   *
   * @return A copy of the current object mapper.
   */
  public ObjectMapper getObjectMapper() {
<span class="nc" id="L264">    return mapper.copy();</span>
  }

  /**
   * Set a custom host name for the target service.
   *
   * @param host The host name of the target service.
   * @return This object.
   */
  public ApiClient setHost(String host) {
<span class="nc" id="L274">    this.host = host;</span>
<span class="nc" id="L275">    return this;</span>
  }

  /**
   * Set a custom port number for the target service.
   *
   * @param port The port of the target service. Set this to -1 to reset the
   *             value to the default for the scheme.
   * @return This object.
   */
  public ApiClient setPort(int port) {
<span class="nc" id="L286">    this.port = port;</span>
<span class="nc" id="L287">    return this;</span>
  }

  /**
   * Set a custom base path for the target service, for example '/v2'.
   *
   * @param basePath The base path against which the rest of the path is
   *                 resolved.
   * @return This object.
   */
  public ApiClient setBasePath(String basePath) {
<span class="nc" id="L298">    this.basePath = basePath;</span>
<span class="nc" id="L299">    return this;</span>
  }

  /**
   * Get the base URI to resolve the endpoint paths against.
   *
   * @return The complete base URI that the rest of the API parameters are
   * resolved against.
   */
  public String getBaseUri() {
<span class="nc bnc" id="L309" title="All 2 branches missed.">    return scheme + &quot;://&quot; + host + (port == -1 ? &quot;&quot; : &quot;:&quot; + port) + basePath;</span>
  }

  /**
   * Set a custom scheme for the target service, for example 'https'.
   *
   * @param scheme The scheme of the target service
   * @return This object.
   */
  public ApiClient setScheme(String scheme){
<span class="nc" id="L319">    this.scheme = scheme;</span>
<span class="nc" id="L320">    return this;</span>
  }

  /**
   * Set a custom request interceptor.
   *
   * &lt;p&gt;A request interceptor is a mechanism for altering each request before it
   * is sent. After the request has been fully configured but not yet built, the
   * request builder is passed into this function for further modification,
   * after which it is sent out.&lt;/p&gt;
   *
   * &lt;p&gt;This is useful for altering the requests in a custom manner, such as
   * adding headers. It could also be used for logging and monitoring.&lt;/p&gt;
   *
   * @param interceptor A function invoked before creating each request. A value
   *                    of null resets the interceptor to a no-op.
   * @return This object.
   */
  public ApiClient setRequestInterceptor(Consumer&lt;HttpRequest.Builder&gt; interceptor) {
<span class="nc" id="L339">    this.interceptor = interceptor;</span>
<span class="nc" id="L340">    return this;</span>
  }

  /**
   * Get the custom interceptor.
   *
   * @return The custom interceptor that was set, or null if there isn't any.
   */
  public Consumer&lt;HttpRequest.Builder&gt; getRequestInterceptor() {
<span class="nc" id="L349">    return interceptor;</span>
  }

  /**
   * Set a custom response interceptor.
   *
   * &lt;p&gt;This is useful for logging, monitoring or extraction of header variables&lt;/p&gt;
   *
   * @param interceptor A function invoked before creating each request. A value
   *                    of null resets the interceptor to a no-op.
   * @return This object.
   */
  public ApiClient setResponseInterceptor(Consumer&lt;HttpResponse&lt;InputStream&gt;&gt; interceptor) {
<span class="nc" id="L362">    this.responseInterceptor = interceptor;</span>
<span class="nc" id="L363">    return this;</span>
  }

 /**
   * Get the custom response interceptor.
   *
   * @return The custom interceptor that was set, or null if there isn't any.
   */
  public Consumer&lt;HttpResponse&lt;InputStream&gt;&gt; getResponseInterceptor() {
<span class="nc" id="L372">    return responseInterceptor;</span>
  }

  /**
   * Set a custom async response interceptor. Use this interceptor when asyncNative is set to 'true'.
   *
   * &lt;p&gt;This is useful for logging, monitoring or extraction of header variables&lt;/p&gt;
   *
   * @param interceptor A function invoked before creating each request. A value
   *                    of null resets the interceptor to a no-op.
   * @return This object.
   */
  public ApiClient setAsyncResponseInterceptor(Consumer&lt;HttpResponse&lt;String&gt;&gt; interceptor) {
<span class="nc" id="L385">    this.asyncResponseInterceptor = interceptor;</span>
<span class="nc" id="L386">    return this;</span>
  }

 /**
   * Get the custom async response interceptor. Use this interceptor when asyncNative is set to 'true'.
   *
   * @return The custom interceptor that was set, or null if there isn't any.
   */
  public Consumer&lt;HttpResponse&lt;String&gt;&gt; getAsyncResponseInterceptor() {
<span class="nc" id="L395">    return asyncResponseInterceptor;</span>
  }

  /**
   * Set the read timeout for the http client.
   *
   * &lt;p&gt;This is the value used by default for each request, though it can be
   * overridden on a per-request basis with a request interceptor.&lt;/p&gt;
   *
   * @param readTimeout The read timeout used by default by the http client.
   *                    Setting this value to null resets the timeout to an
   *                    effectively infinite value.
   * @return This object.
   */
  public ApiClient setReadTimeout(Duration readTimeout) {
<span class="nc" id="L410">    this.readTimeout = readTimeout;</span>
<span class="nc" id="L411">    return this;</span>
  }

  /**
   * Get the read timeout that was set.
   *
   * @return The read timeout, or null if no timeout was set. Null represents
   * an infinite wait time.
   */
  public Duration getReadTimeout() {
<span class="nc" id="L421">    return readTimeout;</span>
  }
  /**
   * Sets the connect timeout (in milliseconds) for the http client.
   *
   * &lt;p&gt; In the case where a new connection needs to be established, if
   * the connection cannot be established within the given {@code
   * duration}, then {@link HttpClient#send(HttpRequest,BodyHandler)
   * HttpClient::send} throws an {@link HttpConnectTimeoutException}, or
   * {@link HttpClient#sendAsync(HttpRequest,BodyHandler)
   * HttpClient::sendAsync} completes exceptionally with an
   * {@code HttpConnectTimeoutException}. If a new connection does not
   * need to be established, for example if a connection can be reused
   * from a previous request, then this timeout duration has no effect.
   *
   * @param connectTimeout connection timeout in milliseconds
   *
   * @return This object.
   */
  public ApiClient setConnectTimeout(Duration connectTimeout) {
<span class="nc" id="L441">    this.connectTimeout = connectTimeout;</span>
<span class="nc" id="L442">    this.builder.connectTimeout(connectTimeout);</span>
<span class="nc" id="L443">    return this;</span>
  }

  /**
   * Get connection timeout (in milliseconds).
   *
   * @return Timeout in milliseconds
   */
  public Duration getConnectTimeout() {
<span class="nc" id="L452">    return connectTimeout;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>