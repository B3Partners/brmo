<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>BGTLoaderMain.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">BRMO service</a> &gt; <a href="../index.html" class="el_bundle">bgt-loader</a> &gt; <a href="index.source.html" class="el_package">nl.b3p.brmo.bgt.loader.cli</a> &gt; <span class="el_source">BGTLoaderMain.java</span></div><h1>BGTLoaderMain.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2021 B3Partners B.V.
 *
 * SPDX-License-Identifier: MIT
 */

package nl.b3p.brmo.bgt.loader.cli;

import static nl.b3p.brmo.bgt.loader.Utils.formatTimeSince;
import static nl.b3p.brmo.bgt.loader.Utils.getBundleString;
import static nl.b3p.brmo.bgt.loader.Utils.getLoaderVersion;
import static nl.b3p.brmo.bgt.loader.Utils.getMessageFormattedString;
import static nl.b3p.brmo.bgt.loader.Utils.getUserAgent;
import static nl.b3p.brmo.bgt.schema.BGTSchemaMapper.Metadata;
import static org.apache.commons.io.FileUtils.byteCountToDisplaySize;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.net.URI;
import java.sql.SQLException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;
import nl.b3p.brmo.bgt.download.model.DeltaCustomDownloadRequest;
import nl.b3p.brmo.bgt.loader.BGTDatabase;
import nl.b3p.brmo.bgt.loader.ProgressReporter;
import nl.b3p.brmo.bgt.loader.ResumingBGTDownloadInputStream;
import nl.b3p.brmo.bgt.loader.Utils;
import nl.b3p.brmo.bgt.schema.BGTObjectTableWriter;
import nl.b3p.brmo.bgt.schema.BGTSchemaMapper;
import nl.b3p.brmo.sql.dialect.SQLDialect;
import nl.b3p.brmo.util.CountingSeekableByteChannel;
import nl.b3p.brmo.util.http.HttpSeekableByteChannel;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.io.input.CloseShieldInputStream;
import org.apache.commons.io.input.CountingInputStream;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.log4j.PropertyConfigurator;
import org.geotools.util.logging.Logging;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.ExitCode;
import picocli.CommandLine.IVersionProvider;
import picocli.CommandLine.Mixin;
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;

@Command(
    name = &quot;bgt-loader&quot;,
    mixinStandardHelpOptions = true,
    versionProvider = BGTLoaderMain.class,
    resourceBundle = Utils.BUNDLE_NAME,
    subcommands = {DownloadCommand.class})
<span class="fc" id="L64">public class BGTLoaderMain implements IVersionProvider {</span>
  private static Log log;

  /**
   * init logging.
   *
   * @param standAlone set to {@code false} when using in a preconfigured environment, eg. calling
   *     methods from a servlet, use {@code true} for commandline usage.
   */
  public static void configureLogging(boolean standAlone) {
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">    if (standAlone) {</span>
<span class="fc" id="L75">      PropertyConfigurator.configure(</span>
<span class="fc" id="L76">          BGTLoaderMain.class.getResourceAsStream(&quot;/bgt-loader-cli-log4.properties&quot;));</span>
<span class="fc" id="L77">      log = LogFactory.getLog(BGTLoaderMain.class);</span>
      try {
<span class="fc" id="L79">        Logging.ALL.setLoggerFactory(&quot;org.geotools.util.logging.Log4JLoggerFactory&quot;);</span>
<span class="nc" id="L80">      } catch (ClassNotFoundException ignored) {</span>
<span class="pc" id="L81">      }</span>
    } else {
<span class="nc" id="L83">      log = LogFactory.getLog(BGTLoaderMain.class);</span>
    }
<span class="fc" id="L85">  }</span>

  public static void main(String[] args) {
<span class="nc" id="L88">    configureLogging(true);</span>
<span class="nc" id="L89">    CommandLine cmd = new CommandLine(new BGTLoaderMain()).setUsageHelpAutoWidth(true);</span>
<span class="nc" id="L90">    System.exit(cmd.execute(args));</span>
<span class="nc" id="L91">  }</span>

  @Command(name = &quot;schema&quot;, sortOptions = false)
  public int schema(
      @Option(names = &quot;--dialect&quot;, paramLabel = &quot;&lt;dialect&gt;&quot;, defaultValue = &quot;postgis&quot;)
          BGTDatabase.SQLDialectEnum dialectEnum,
      @Mixin FeatureTypeSelectionOptions featureTypeSelectionOptions,
      @Option(names = &quot;--table-prefix&quot;, defaultValue = &quot;&quot;, hidden = true) String tablePrefix,
      @Option(
              names = {&quot;-h&quot;, &quot;--help&quot;},
              usageHelp = true)
          boolean showHelp)
      throws SQLException {
<span class="nc" id="L104">    SQLDialect dialect = BGTDatabase.createDialect(dialectEnum);</span>
    // For schema generation include plaatsbepalingspunt with 'all' and 'bgt'
<span class="nc bnc" id="L106" title="All 2 branches missed.">    if (featureTypeSelectionOptions.featureTypes.contains(&quot;all&quot;)</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">        || featureTypeSelectionOptions.featureTypes.contains(&quot;bgt&quot;)) {</span>
<span class="nc" id="L108">      featureTypeSelectionOptions</span>
<span class="nc" id="L109">          .getFeatureTypes()</span>
<span class="nc" id="L110">          .add(DeltaCustomDownloadRequest.FeaturetypesEnum.PLAATSBEPALINGSPUNT.getValue());</span>
    }
<span class="nc" id="L112">    Set&lt;String&gt; tableNames =</span>
<span class="nc" id="L113">        featureTypeSelectionOptions.getFeatureTypesList().stream()</span>
<span class="nc" id="L114">            .map(DeltaCustomDownloadRequest.FeaturetypesEnum::getValue)</span>
<span class="nc" id="L115">            .collect(Collectors.toSet());</span>
<span class="nc" id="L116">    BGTSchemaMapper bgtSchemaMapper = BGTSchemaMapper.getInstance();</span>
<span class="nc" id="L117">    bgtSchemaMapper.printSchema(</span>
        dialect,
        tablePrefix,
        objectType -&gt;
<span class="nc" id="L121">            tableNames.contains(bgtSchemaMapper.getTableNameForObjectType(objectType, &quot;&quot;)));</span>
<span class="nc" id="L122">    return ExitCode.OK;</span>
  }

  @Command(name = &quot;load&quot;, sortOptions = false)
  public int load(
      @Mixin DatabaseOptions dbOptions,
      @Mixin LoadOptions loadOptions,
      @Mixin FeatureTypeSelectionOptions featureTypeSelectionOptions,
      @Parameters(paramLabel = &quot;&lt;file&gt;&quot;) String file,
      @Mixin CLIOptions cliOptions,
      @Option(
              names = {&quot;-h&quot;, &quot;--help&quot;},
              usageHelp = true)
          boolean showHelp)
      throws Exception {

<span class="fc" id="L138">    log.info(getUserAgent());</span>

<span class="fc" id="L140">    try (BGTDatabase db = new BGTDatabase(dbOptions)) {</span>
<span class="fc" id="L141">      BGTObjectTableWriter writer = db.createObjectTableWriter(loadOptions, dbOptions);</span>

      ProgressReporter progressReporter =
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">          cliOptions.isConsoleProgressEnabled()</span>
<span class="nc" id="L145">              ? new ConsoleProgressReporter()</span>
<span class="fc" id="L146">              : new ProgressReporter();</span>
<span class="fc" id="L147">      writer.setProgressUpdater(progressReporter);</span>

<span class="pc bpc" id="L149" title="1 of 2 branches missed.">      if (loadOptions.createSchema) {</span>
<span class="fc" id="L150">        db.createMetadataTable(loadOptions);</span>
      }

<span class="fc bfc" id="L153" title="All 6 branches covered.">      if (file.endsWith(&quot;.zip&quot;) &amp;&amp; (file.startsWith(&quot;http://&quot;) || file.startsWith(&quot;https://&quot;))) {</span>
<span class="fc" id="L154">        loadZipFromURI(new URI(file), writer, featureTypeSelectionOptions, loadOptions, true);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">      } else if (file.endsWith(&quot;.zip&quot;)) {</span>
<span class="fc" id="L156">        loadZip(new File(file), writer, featureTypeSelectionOptions);</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">      } else if (file.matches(&quot;.*\\.[xg]ml&quot;)) {</span>
<span class="fc" id="L158">        loadXml(new File(file), writer);</span>
      } else {
<span class="nc" id="L160">        log.error(getMessageFormattedString(&quot;load.invalid_extension&quot;, file));</span>
<span class="nc" id="L161">        return ExitCode.USAGE;</span>
      }

<span class="pc bpc" id="L164" title="1 of 2 branches missed.">      if (writer.getProgress() == null) {</span>
<span class="nc" id="L165">        log.error(getBundleString(&quot;error.no_feature_types&quot;));</span>
<span class="nc" id="L166">        return ExitCode.SOFTWARE;</span>
      }
<span class="fc" id="L168">      db.setMetadataValue(Metadata.LOADER_VERSION, getLoaderVersion());</span>
      // Set feature types list from options, not MutatieInhoud (if input has it)...
      // FIXME if downloaded initial extract has less object types, update will fail -- should
      // set to only encountered
      // feature types
<span class="fc" id="L173">      db.setFeatureTypesEnumMetadata(featureTypeSelectionOptions.getFeatureTypesList());</span>
<span class="fc" id="L174">      db.setMetadataValue(Metadata.INCLUDE_HISTORY, loadOptions.includeHistory + &quot;&quot;);</span>
<span class="fc" id="L175">      db.setMetadataValue(Metadata.LINEARIZE_CURVES, loadOptions.linearizeCurves + &quot;&quot;);</span>
<span class="fc" id="L176">      db.setMetadataValue(Metadata.TABLE_PREFIX, loadOptions.tablePrefix);</span>
<span class="fc" id="L177">      BGTObjectTableWriter.BGTProgress progress = writer.getProgress();</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">      if (progress.getMutatieInhoud() != null) {</span>
<span class="fc" id="L179">        db.setMetadataForMutaties(progress.getMutatieInhoud());</span>
<span class="fc" id="L180">        db.setMetadataValue(Metadata.GEOM_FILTER, progress.getMutatieInhoud().getGebied());</span>

<span class="fc" id="L182">        log.info(</span>
<span class="fc" id="L183">            getMessageFormattedString(</span>
                &quot;load.mutatie&quot;,
<span class="fc" id="L185">                progress.getMutatieInhoud().getMutatieType(),</span>
<span class="fc" id="L186">                progress.getMutatieInhoud().getLeveringsId()));</span>
      }
<span class="fc" id="L188">      progressReporter.reportTotalSummary();</span>
<span class="fc" id="L189">      db.getConnection().commit();</span>
<span class="nc" id="L190">    }</span>

<span class="fc" id="L192">    return ExitCode.OK;</span>
  }

  private static boolean isBGTZipEntrySelected(
      String entryName,
      FeatureTypeSelectionOptions featureTypeSelectionOptions,
      boolean logSkipAsInfo) {
<span class="fc" id="L199">    Set&lt;DeltaCustomDownloadRequest.FeaturetypesEnum&gt; featureTypes =</span>
<span class="fc" id="L200">        featureTypeSelectionOptions.getFeatureTypesList();</span>
<span class="fc" id="L201">    Pattern p = Pattern.compile(&quot;bgt_(.+).[xg]ml&quot;);</span>

<span class="fc" id="L203">    Matcher m = p.matcher(entryName);</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">    if (!m.matches()) {</span>
<span class="nc" id="L205">      log.warn(getMessageFormattedString(&quot;load.skip_entry&quot;, entryName));</span>
<span class="nc" id="L206">      return false;</span>
    }
<span class="fc" id="L208">    String tableName = m.group(1);</span>
    try {
<span class="fc" id="L210">      DeltaCustomDownloadRequest.FeaturetypesEnum featureType =</span>
<span class="fc" id="L211">          DeltaCustomDownloadRequest.FeaturetypesEnum.fromValue(tableName);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">      if (!featureTypes.contains(featureType)) {</span>
<span class="fc" id="L213">        String msg = getMessageFormattedString(&quot;load.skip_unselected&quot;, tableName);</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        if (logSkipAsInfo) {</span>
<span class="nc" id="L215">          log.info(msg);</span>
        } else {
<span class="fc" id="L217">          log.debug(msg);</span>
        }
<span class="fc" id="L219">        return false;</span>
      } else {
<span class="fc" id="L221">        return true;</span>
      }
<span class="nc" id="L223">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L224">      log.warn(getMessageFormattedString(&quot;load.skip_unknown_feature_type&quot;, entryName));</span>
<span class="nc" id="L225">      return false;</span>
    }
  }

  public void loadZipFromURI(
      URI uri,
      BGTObjectTableWriter writer,
      FeatureTypeSelectionOptions featureTypeSelectionOptions,
      LoadOptions loadOptions,
      boolean showSelected)
      throws Exception {
<span class="fc" id="L236">    log.info(getMessageFormattedString(&quot;download.downloading_from&quot;, uri));</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">    if (loadOptions.isHttpZipRandomAccess()) {</span>
<span class="fc" id="L238">      loadZipFromURIUsingRandomAccess(</span>
<span class="fc" id="L239">          uri, writer, featureTypeSelectionOptions, showSelected, loadOptions.isDebugHttpSeeks());</span>
    } else {
<span class="fc" id="L241">      loadZipFromURIUsingStreaming(uri, writer, featureTypeSelectionOptions);</span>
    }
<span class="fc" id="L243">  }</span>

  public void loadZipFromURIUsingRandomAccess(
      URI uri,
      BGTObjectTableWriter writer,
      FeatureTypeSelectionOptions featureTypeSelectionOptions,
      boolean showSelected,
      boolean debugHttpSeeks)
      throws Exception {
<span class="fc" id="L252">    Instant start = Instant.now();</span>

    // NOTE: it can happen that not all entries from a ZIP are read because of
    // https://issues.apache.org/jira/browse/COMPRESS-584
    // This happened with
    // https://api.pdok.nl/lv/bgt/download/v1_0/cache/2/ebe787b3-e113-4331-ab96-edd1e9bf5aa7/bgt-citygml-nl-nopbp.zip

<span class="fc" id="L259">    try (HttpSeekableByteChannel channel =</span>
<span class="fc" id="L260">            new HttpSeekableByteChannel(uri).withDebug(debugHttpSeeks);</span>
<span class="fc" id="L261">        CountingSeekableByteChannel loggingChannel = new CountingSeekableByteChannel(channel);</span>
<span class="fc" id="L262">        org.apache.commons.compress.archivers.zip.ZipFile zipFile =</span>
            new org.apache.commons.compress.archivers.zip.ZipFile(
<span class="fc" id="L264">                loggingChannel, uri.toString(), &quot;UTF8&quot;, false, true)) {</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">      if (debugHttpSeeks) {</span>
<span class="fc" id="L266">        System.out.println();</span>
      }
<span class="fc" id="L268">      int count = 0;</span>
<span class="fc" id="L269">      long uncompressed = 0;</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">      for (Iterator&lt;ZipArchiveEntry&gt; it = zipFile.getEntries().asIterator(); it.hasNext(); ) {</span>
<span class="fc" id="L271">        ZipArchiveEntry entry = it.next();</span>
<span class="fc" id="L272">        count++;</span>
<span class="fc" id="L273">        uncompressed += entry.getSize();</span>
<span class="fc" id="L274">      }</span>
<span class="fc" id="L275">      log.info(</span>
<span class="fc" id="L276">          getMessageFormattedString(</span>
              &quot;download.zip.read&quot;,
<span class="fc" id="L278">              formatTimeSince(start),</span>
<span class="fc" id="L279">              count,</span>
<span class="fc" id="L280">              byteCountToDisplaySize(channel.size()),</span>
<span class="fc" id="L281">              byteCountToDisplaySize(uncompressed)));</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">      if (debugHttpSeeks) {</span>
<span class="fc" id="L283">        log.info(</span>
<span class="fc" id="L284">            getMessageFormattedString(</span>
                &quot;download.zip.debug-http-seeks.entries&quot;,
<span class="fc" id="L286">                loggingChannel.getNonConsecutiveIops(),</span>
<span class="fc" id="L287">                channel.getHttpRequestCount(),</span>
<span class="fc" id="L288">                channel.getBytesRead()));</span>
      }
<span class="fc" id="L290">      loggingChannel.setLoggingEnabled(false);</span>

<span class="fc" id="L292">      ProgressReporter progressReporter = (ProgressReporter) writer.getProgressUpdater();</span>
<span class="fc" id="L293">      List&lt;ZipArchiveEntry&gt; selected = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L294">      zipFile</span>
<span class="fc" id="L295">          .getEntries()</span>
<span class="fc" id="L296">          .asIterator()</span>
<span class="fc" id="L297">          .forEachRemaining(</span>
              entry -&gt; {
<span class="fc bfc" id="L299" title="All 2 branches covered.">                if (isBGTZipEntrySelected(entry.getName(), featureTypeSelectionOptions, false)) {</span>
<span class="fc" id="L300">                  selected.add(entry);</span>
                }
<span class="fc" id="L302">              });</span>

<span class="pc bpc" id="L304" title="1 of 2 branches missed.">      if (selected.size() &gt; 1) {</span>
        // Only report total percentage when more than one entry
<span class="fc" id="L306">        long totalSize = selected.stream().map(ZipArchiveEntry::getSize).reduce(0L, Long::sum);</span>
<span class="fc" id="L307">        Long totalCompressedSize =</span>
<span class="fc" id="L308">            selected.stream().map(ZipArchiveEntry::getCompressedSize).reduce(0L, Long::sum);</span>
<span class="fc" id="L309">        progressReporter.setTotalBytes(totalSize);</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (showSelected) {</span>
<span class="fc" id="L311">          log.info(</span>
<span class="fc" id="L312">              getMessageFormattedString(</span>
                  &quot;download.zip.selected&quot;,
<span class="fc" id="L314">                  selected.size(),</span>
<span class="fc" id="L315">                  byteCountToDisplaySize(totalCompressedSize),</span>
<span class="fc" id="L316">                  byteCountToDisplaySize(totalSize)));</span>
        }
      }
<span class="fc" id="L319">      Long[] previousEntriesBytesRead = new Long[] {0L};</span>
<span class="fc" id="L320">      progressReporter.setTotalBytesReadFunction(</span>
<span class="nc" id="L321">          () -&gt; previousEntriesBytesRead[0] + writer.getProgress().getBytesRead());</span>

<span class="fc bfc" id="L323" title="All 2 branches covered.">      for (ZipArchiveEntry entry : selected) {</span>
<span class="fc" id="L324">        progressReporter.startNewFile(entry.getName(), entry.getSize());</span>
<span class="fc" id="L325">        writer.write(zipFile.getInputStream(entry));</span>
<span class="fc" id="L326">      }</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">      if (debugHttpSeeks) {</span>
<span class="fc" id="L328">        log.info(</span>
<span class="fc" id="L329">            getMessageFormattedString(</span>
                &quot;download.zip.debug-http-seeks.totals&quot;,
<span class="fc" id="L331">                loggingChannel.getNonConsecutiveIops(),</span>
<span class="fc" id="L332">                channel.getHttpRequestCount(),</span>
<span class="fc" id="L333">                channel.getBytesRead(),</span>
<span class="fc" id="L334">                byteCountToDisplaySize(channel.getBytesRead())));</span>
      }
    }
<span class="fc" id="L337">  }</span>

  public void loadZipFromURIUsingStreaming(
      URI downloadURI,
      BGTObjectTableWriter writer,
      FeatureTypeSelectionOptions featureTypeSelectionOptions)
      throws Exception {
<span class="fc" id="L344">    ProgressReporter progressReporter = (ProgressReporter) writer.getProgressUpdater();</span>

<span class="fc" id="L346">    try (InputStream input = new ResumingBGTDownloadInputStream(downloadURI, writer)) {</span>
<span class="fc" id="L347">      CountingInputStream countingInputStream = new CountingInputStream(input);</span>
<span class="fc" id="L348">      progressReporter.setTotalBytesReadFunction(countingInputStream::getByteCount);</span>

<span class="fc" id="L350">      try (ZipInputStream zis = new ZipInputStream(countingInputStream)) {</span>
<span class="fc" id="L351">        ZipEntry entry = zis.getNextEntry();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        while (entry != null) {</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">          if (isBGTZipEntrySelected(entry.getName(), featureTypeSelectionOptions, true)) {</span>
<span class="fc" id="L354">            progressReporter.startNewFile(entry.getName(), null);</span>
<span class="fc" id="L355">            writer.write(CloseShieldInputStream.wrap(zis));</span>
          }
<span class="fc" id="L357">          entry = zis.getNextEntry();</span>
        }
      }
    }
<span class="fc" id="L361">  }</span>

  public void loadZip(
      File file,
      BGTObjectTableWriter writer,
      FeatureTypeSelectionOptions featureTypeSelectionOptions)
      throws Exception {
<span class="fc" id="L368">    try (ZipFile zipFile = new ZipFile(file)) {</span>
<span class="fc" id="L369">      List&lt;ZipEntry&gt; entries =</span>
<span class="fc" id="L370">          zipFile.stream()</span>
<span class="fc" id="L371">              .filter(</span>
                  entry -&gt;
<span class="fc" id="L373">                      isBGTZipEntrySelected(entry.getName(), featureTypeSelectionOptions, false))</span>
<span class="fc" id="L374">              .collect(Collectors.toList());</span>

<span class="fc" id="L376">      ProgressReporter progressReporter = (ProgressReporter) writer.getProgressUpdater();</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">      if (entries.size() &gt; 1) {</span>
        // Only report total percentage when more than one entry
<span class="fc" id="L379">        Long totalSize = entries.stream().map(ZipEntry::getSize).reduce(0L, Long::sum);</span>
<span class="fc" id="L380">        progressReporter.setTotalBytes(totalSize);</span>
      }
<span class="fc" id="L382">      Long[] previousEntriesBytesRead = new Long[] {0L};</span>
<span class="fc" id="L383">      progressReporter.setTotalBytesReadFunction(</span>
<span class="nc" id="L384">          () -&gt; previousEntriesBytesRead[0] + writer.getProgress().getBytesRead());</span>

<span class="fc bfc" id="L386" title="All 2 branches covered.">      for (ZipEntry entry : entries) {</span>
<span class="fc" id="L387">        try (InputStream in = zipFile.getInputStream(entry)) {</span>
          // getSize() will not return -1 because ZipFile uses random access to read the
          // ZIP central directory
<span class="fc" id="L390">          loadInputStream(entry.getName(), in, entry.getSize(), writer);</span>
<span class="fc" id="L391">          previousEntriesBytesRead[0] += entry.getSize();</span>
        }
<span class="fc" id="L393">      }</span>
<span class="fc" id="L394">      progressReporter.reportTotalSummary();</span>
    }
<span class="fc" id="L396">  }</span>

  public void loadXml(File file, BGTObjectTableWriter writer) throws Exception {
<span class="fc" id="L399">    try (FileInputStream in = new FileInputStream(file)) {</span>
<span class="fc" id="L400">      loadInputStream(file.getName(), in, file.length(), writer);</span>
    }
<span class="fc" id="L402">  }</span>

  public void loadInputStream(
      String name, InputStream input, long size, BGTObjectTableWriter writer) throws Exception {
<span class="fc" id="L406">    ProgressReporter progressReporter = (ProgressReporter) writer.getProgressUpdater();</span>
<span class="fc" id="L407">    progressReporter.startNewFile(name, size);</span>
<span class="fc" id="L408">    writer.write(input);</span>
<span class="fc" id="L409">  }</span>

  @Override
  public String[] getVersion() {
<span class="nc" id="L413">    return new String[] {Utils.getLoaderVersion(), Utils.getUserAgent()};</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>